import re
from typing import Optional
import numpy as np
import pandas as pd
import requests
import streamlit as st
import yfinance as yf
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta

# ---------------------------------------------------------------------
# CONFIG
# ---------------------------------------------------------------------
st.set_page_config(page_title="Scanner Trading", layout="wide")
st.title("üìà Scanner Trading")

# ---------------------------------------------------------------------
# LINE BREAK CALCUL SELON BOURSORAMA (FIXE)
# ---------------------------------------------------------------------
def calculate_boursorama_linebreak(close_prices, reversal=2):
    """
    Calcul LineBreak selon l'impl√©mentation Boursorama
    reversal=2 FIXE comme sur Boursorama
    """
    if len(close_prices) < reversal + 1:
        return []
    
    bricks = []
    # Premi√®re brique bas√©e sur les deux premiers cours
    bricks.append({
        'type': 'green' if close_prices[1] > close_prices[0] else 'red',
        'open': close_prices[0],
        'close': close_prices[1],
        'index': 1
    })
    
    for i in range(2, len(close_prices)):
        current_close = close_prices[i]
        last_brick = bricks[-1]
        
        # R√àGLE BOURSORAMA : V√©rifier d'abord les inversions
        reversal_occurred = False
        
        if last_brick['type'] == 'green':
            # Inversion si on casse le bas des 2 derni√®res briques vertes
            if len(bricks) >= reversal:
                recent_lows = [bricks[-j]['open'] for j in range(1, min(reversal, len(bricks)) + 1)]
                min_recent_low = min(recent_lows)
                if current_close < min_recent_low:
                    bricks.append({
                        'type': 'red',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
                    reversal_occurred = True
        
        else:  # red brick
            # Inversion si on casse le haut des 2 derni√®res briques rouges
            if len(bricks) >= reversal:
                recent_highs = [bricks[-j]['open'] for j in range(1, min(reversal, len(bricks)) + 1)]
                max_recent_high = max(recent_highs)
                if current_close > max_recent_high:
                    bricks.append({
                        'type': 'green',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
                    reversal_occurred = True
        
        # Si pas d'inversion, continuer la tendance actuelle
        if not reversal_occurred:
            if last_brick['type'] == 'green':
                if current_close > last_brick['close']:
                    bricks.append({
                        'type': 'green',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
            else:  # red
                if current_close < last_brick['close']:
                    bricks.append({
                        'type': 'red',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
    
    return bricks

def get_clean_data(symbol, period="3mo"):
    """R√©cup√®re des donn√©es propres avec actualisation compl√®te"""
    try:
        # T√©l√©charger les donn√©es avec une p√©riode qui garantit l'actualisation
        df = yf.download(symbol, period=period, interval="1d", auto_adjust=True, progress=False)
        if df.empty:
            return None
        
        # Nettoyage
        df = df[['Open', 'High', 'Low', 'Close', 'Volume']].copy()
        df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
        df = df.dropna()
        
        # CORRECTION : Ne pas ignorer le jour en cours pour avoir les donn√©es les plus r√©centes
        # V√©rifier si les donn√©es sont √† jour
        last_data_date = df.index[-1].date()
        today = datetime.now().date()
        
        # Si les donn√©es ont plus d'1 jour de retard, essayer de forcer l'actualisation
        if (today - last_data_date).days > 1:
            # T√©l√©charger avec une p√©riode diff√©rente pour forcer l'actualisation
            df_fresh = yf.download(symbol, period="1mo", interval="1d", auto_adjust=True, progress=False)
            if not df_fresh.empty:
                df_fresh = df_fresh[['Open', 'High', 'Low', 'Close', 'Volume']].copy()
                df_fresh.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
                df_fresh = df_fresh.dropna()
                if len(df_fresh) > 0:
                    df = df_fresh
        
        return df
    except Exception as e:
        st.error(f"Erreur lors du t√©l√©chargement des donn√©es pour {symbol}: {str(e)}")
        return None

def detect_boursorama_signal(df):
    """D√©tecte les signaux selon Boursorama avec reversal=2 FIXE"""
    if df is None or len(df) < 10:
        return False, []
    
    close_prices = df['Close'].values
    bricks = calculate_boursorama_linebreak(close_prices, reversal=2)
    
    if len(bricks) < 2:
        return False, bricks
    
    last_two = bricks[-2:]
    signal_detected = (
        (last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green') or
        (last_two[0]['type'] == 'green' and last_two[1]['type'] == 'red')
    )
    
    return signal_detected, bricks

# ---------------------------------------------------------------------
# CALCUL MACD
# ---------------------------------------------------------------------
def calculate_macd(df, fast=12, slow=26, signal=9):
    """Calcule le MACD"""
    df = df.copy()
    
    # EMA rapide et lente
    df['EMA_fast'] = df['Close'].ewm(span=fast).mean()
    df['EMA_slow'] = df['Close'].ewm(span=slow).mean()
    
    # MACD et ligne de signal
    df['MACD'] = df['EMA_fast'] - df['EMA_slow']
    df['MACD_signal'] = df['MACD'].ewm(span=signal).mean()
    df['MACD_histogram'] = df['MACD'] - df['MACD_signal']
    
    return df

# ---------------------------------------------------------------------
# GRAPHIQUES AM√âLIOR√âS AVEC MACD ET DATES
# ---------------------------------------------------------------------
def create_pro_chart(df, title, show_bollinger=True, show_ema=True, show_macd=True):
    """Graphique trading professionnel avec MACD"""
    # Calculer le MACD si demand√©
    if show_macd:
        df = calculate_macd(df)
    
    if show_macd:
        fig = make_subplots(
            rows=2, cols=1,
            shared_xaxes=True,
            vertical_spacing=0.03,
            subplot_titles=(f"<b>{title}</b>", "<b>MACD</b>"),
            row_heights=[0.7, 0.3]
        )
    else:
        fig = make_subplots(rows=1, cols=1, subplot_titles=(f"<b>{title}</b>",))
    
    # Bougies
    row = 1 if show_macd else 1
    fig.add_trace(go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        increasing_line_color='#00CC00',
        decreasing_line_color='#FF0000',
        name='Prix'
    ), row=row, col=1)
    
    # Bollinger Bands
    if show_bollinger and len(df) > 20:
        df['SMA20'] = df['Close'].rolling(20).mean()
        df['STD20'] = df['Close'].rolling(20).std()
        df['BB_Upper'] = df['SMA20'] + (df['STD20'] * 2)
        df['BB_Lower'] = df['SMA20'] - (df['STD20'] * 2)
        
        fig.add_trace(go.Scatter(
            x=df.index, y=df['BB_Upper'],
            line=dict(color='orange', width=1, dash='dash'),
            name='Bollinger Upper'
        ), row=row, col=1)
        
        fig.add_trace(go.Scatter(
            x=df.index, y=df['BB_Lower'],
            line=dict(color='orange', width=1, dash='dash'),
            fill='tonexty',
            fillcolor='rgba(255,165,0,0.1)',
            name='Bollinger Lower'
        ), row=row, col=1)
    
    # EMA 20
    if show_ema and len(df) > 20:
        df['EMA20'] = df['Close'].ewm(span=20).mean()
        fig.add_trace(go.Scatter(
            x=df.index, y=df['EMA20'],
            line=dict(color='blue', width=2),
            name='EMA 20'
        ), row=row, col=1)
    
    # MACD
    if show_macd and 'MACD' in df.columns:
        # MACD line
        fig.add_trace(go.Scatter(
            x=df.index, y=df['MACD'],
            line=dict(color='blue', width=2),
            name='MACD'
        ), row=2, col=1)
        
        # Signal line
        fig.add_trace(go.Scatter(
            x=df.index, y=df['MACD_signal'],
            line=dict(color='red', width=1.5),
            name='Signal'
        ), row=2, col=1)
        
        # Histogramme
        colors_histogram = ['green' if x >= 0 else 'red' for x in df['MACD_histogram']]
        fig.add_trace(go.Bar(
            x=df.index, y=df['MACD_histogram'],
            marker_color=colors_histogram,
            name='Histogram',
            opacity=0.6
        ), row=2, col=1)
        
        # Ligne z√©ro
        fig.add_hline(y=0, line_dash="dot", line_color="gray", row=2, col=1)
    
    fig.update_layout(
        height=700,
        template='plotly_white',
        xaxis_rangeslider_visible=False,
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
    )
    
    if show_macd:
        fig.update_yaxes(title_text="Prix", row=1, col=1)
        fig.update_yaxes(title_text="MACD", row=2, col=1)
    else:
        fig.update_yaxes(title_text="Prix", row=1, col=1)
    
    return fig

def create_linebreak_chart(df, bricks, title):
    """Graphique LineBreak avec dates"""
    if not bricks or len(bricks) < 2:
        return None
    
    # Prendre les 8-10 derni√®res briques (comme Boursorama)
    display_bricks = bricks[-10:] if len(bricks) > 10 else bricks
    
    fig = go.Figure()
    
    # R√©cup√©rer les dates correspondantes aux briques
    dates = [df.index[brick['index']] for brick in display_bricks]
    
    for i, (brick, date) in enumerate(zip(display_bricks, dates)):
        color = '#00CC00' if brick['type'] == 'green' else '#FF0000'
        border_color = '#009900' if brick['type'] == 'green' else '#CC0000'
        
        # Rectangle de la brique
        low = min(brick['open'], brick['close'])
        high = max(brick['open'], brick['close'])
        
        fig.add_trace(go.Scatter(
            x=[i-0.4, i+0.4, i+0.4, i-0.4, i-0.4],
            y=[low, low, high, high, low],
            fill="toself",
            fillcolor=color,
            line=dict(color=border_color, width=2),
            mode='lines',
            showlegend=False,
            name=f"Brique {i+1}",
            hovertemplate=f"Date: {date.strftime('%d/%m/%Y')}<br>" +
                         f"Type: {brick['type']}<br>" +
                         f"Open: {brick['open']:.2f}<br>" +
                         f"Close: {brick['close']:.2f}<br>" +
                         f"<extra></extra>"
        ))
        
        # Ligne m√©diane (caract√©ristique Boursorama)
        fig.add_trace(go.Scatter(
            x=[i-0.4, i+0.4],
            y=[brick['open'], brick['open']],
            line=dict(color='white', width=1.5),
            mode='lines',
            showlegend=False,
            hoverinfo='skip'
        ))
    
    # Annotation pour les 2 derni√®res briques (signal)
    if len(display_bricks) >= 2:
        last_two = display_bricks[-2:]
        if (last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green'):
            signal_text = "üî¥ ‚Üí üü¢ ROUGE ‚Üí VERT"
            signal_color = "#00CC00"
        elif (last_two[0]['type'] == 'green' and last_two[1]['type'] == 'red'):
            signal_text = "üü¢ ‚Üí üî¥ VERT ‚Üí ROUGE"
            signal_color = "#FF0000"
        else:
            signal_text = None
        
        if signal_text:
            fig.add_annotation(
                x=len(display_bricks)-1,
                y=display_bricks[-1]['close'] * 1.02,
                text=signal_text,
                showarrow=True,
                arrowhead=2,
                arrowcolor=signal_color,
                font=dict(size=14, color=signal_color, family="Arial Black"),
                bgcolor="#F8F9FA",
                bordercolor=signal_color
            )
    
    # Configurer l'axe des x avec les dates
    fig.update_layout(
        title=dict(text=f"<b>{title}</b>", x=0.5, font=dict(size=16)),
        height=500,
        template='plotly_white',
        xaxis=dict(
            tickmode='array',
            tickvals=list(range(len(dates))),
            ticktext=[date.strftime('%d/%m') for date in dates],
            title="Dates (derni√®res briques √† droite)"
        ),
        yaxis=dict(title="Prix"),
        showlegend=False,
        plot_bgcolor='#F8F9FA'
    )
    
    return fig

# ---------------------------------------------------------------------
# LISTES DES INDICES √âTENDUES
# ---------------------------------------------------------------------

# CAC40
CAC40 = [
    ("AIR.PA","Airbus"), ("AI.PA","Air Liquide"), ("ALO.PA","Alstom"), ("MT.AS","ArcelorMittal"),
    ("CS.PA","AXA"), ("BNP.PA","BNP Paribas"), ("CAP.PA","Capgemini"), ("CA.PA","Carrefour"),
    ("ACA.PA","Cr√©dit Agricole"), ("BN.PA","Danone"), ("DSY.PA","Dassault Syst√®mes"),
    ("EL.PA","EssilorLuxottica"), ("RMS.PA","Herm√®s"), ("KER.PA","Kering"),
    ("LR.PA","Legrand"), ("MC.PA","LVMH"), ("ORA.PA","Orange"), ("RI.PA","Pernod Ricard"),
    ("PUB.PA","Publicis"), ("RNO.PA","Renault"), ("GLE.PA","Soci√©t√© G√©n√©rale"),
    ("STLA.PA","Stellantis"), ("SU.PA","Schneider Electric"), ("HO.PA","Thales"),
    ("TTE.PA","TotalEnergies"), ("VIE.PA","Veolia"), ("VIV.PA","Vivendi"),
    ("STM.PA","STMicroelectronics"), ("SGO.PA","Saint-Gobain"), ("DG.PA","Vinci"),
]

# SBF 120 (CAC40 + 80 autres valeurs)
SBF120 = CAC40 + [
    ("AC.PA", "Accor"), ("AF.PA", "Air France-KLM"), ("ATO.PA", "Atos"), 
    ("EN.PA", "Bouygues"), ("BVI.PA", "Bureau Veritas"), ("CO.PA", "Casino Guichard"),
    ("CNP.PA", "CNP Assurances"), ("EDEN.PA", "Edenred"), ("EDF.PA", "EDF"),
    ("EI.PA", "EssilorLuxottica"), ("ERF.PA", "Eurofins Scientific"), ("FR.PA", "Valeo"),
    ("FGR.PA", "Eiffage"), ("ICAD.PA", "Icade"), ("ITP.PA", "Interparfums"),
    ("LI.PA", "Klepierre"), ("OR.PA", "L'Or√©al"), ("MMB.PA", "Lagard√®re"),
    ("LG.PA", "LafargeHolcim"), ("MB.PA", "Michelin"), ("NEX.PA", "Nexans"),
    ("NK.PA", "Imerys"), ("UG.PA", "Peugeot"), ("SAF.PA", "Safran"),
    ("SAN.PA", "Sanofi"), ("SK.PA", "SEB"), ("SOI.PA", "Soitec"),
    ("TEP.PA", "Teleperformance"), ("TFI.PA", "TF1"), ("VK.PA", "Vallourec"),
    ("MF.PA", "Wendel"), ("XR.PA", "Rexel")
]

# Dow Jones (30 grandes entreprises am√©ricaines)
DOW_JONES = [
    ("AAPL", "Apple Inc."), ("MSFT", "Microsoft Corp."), ("AMZN", "Amazon.com Inc."),
    ("GOOGL", "Alphabet Inc."), ("META", "Meta Platforms Inc."), ("TSLA", "Tesla Inc."),
    ("BRK-B", "Berkshire Hathaway"), ("JNJ", "Johnson & Johnson"), ("V", "Visa Inc."),
    ("JPM", "JPMorgan Chase & Co."), ("WMT", "Walmart Inc."), ("PG", "Procter & Gamble"),
    ("UNH", "UnitedHealth Group"), ("DIS", "Walt Disney Co."), ("NVDA", "NVIDIA Corp."),
    ("HD", "Home Depot Inc."), ("PYPL", "PayPal Holdings"), ("NFLX", "Netflix Inc."),
    ("ADBE", "Adobe Inc."), ("CRM", "Salesforce.com"), ("INTC", "Intel Corp."),
    ("CSCO", "Cisco Systems"), ("PFE", "Pfizer Inc."), ("ABT", "Abbott Laboratories"),
    ("T", "AT&T Inc."), ("VZ", "Verizon Communications"), ("KO", "Coca-Cola Co."),
    ("PEP", "PepsiCo Inc."), ("XOM", "Exxon Mobil Corp."), ("CVX", "Chevron Corp.")
]

# NASDAQ 100 (100 principales entreprises tech)
NASDAQ100 = [
    ("AAPL", "Apple Inc."), ("MSFT", "Microsoft Corp."), ("AMZN", "Amazon.com Inc."),
    ("GOOGL", "Alphabet Inc."), ("GOOG", "Alphabet Inc. C"), ("META", "Meta Platforms Inc."),
    ("TSLA", "Tesla Inc."), ("NVDA", "NVIDIA Corp."), ("AVGO", "Broadcom Inc."),
    ("PEP", "PepsiCo Inc."), ("COST", "Costco Wholesale"), ("ADBE", "Adobe Inc."),
    ("CSCO", "Cisco Systems"), ("CMCSA", "Comcast Corp."), ("NFLX", "Netflix Inc."),
    ("INTC", "Intel Corp."), ("AMD", "Advanced Micro Devices"), ("TMUS", "T-Mobile US"),
    ("TXN", "Texas Instruments"), ("QCOM", "Qualcomm Inc."), ("HON", "Honeywell International"),
    ("AMGN", "Amgen Inc."), ("SBUX", "Starbucks Corp."), ("INTU", "Intuit Inc."),
    ("AMAT", "Applied Materials"), ("ISRG", "Intuitive Surgical"), ("MDLZ", "Mondelez International"),
    ("GILD", "Gilead Sciences"), ("ADP", "Automatic Data Processing"), ("VRTX", "Vertex Pharmaceuticals"),
    ("REGN", "Regeneron Pharmaceuticals"), ("ADI", "Analog Devices"), ("BKNG", "Booking Holdings"),
    ("PYPL", "PayPal Holdings"), ("MRNA", "Moderna Inc."), ("LRCX", "Lam Research"),
    ("CSX", "CSX Corp."), ("KLAC", "KLA Corp."), ("SNPS", "Synopsys Inc."),
    ("CDNS", "Cadence Design Systems"), ("ASML", "ASML Holding"), ("CHTR", "Charter Communications"),
    ("MAR", "Marriott International"), ("MU", "Micron Technology"), ("CTAS", "Cintas Corp."),
    ("ORLY", "O'Reilly Automotive"), ("ABNB", "Airbnb Inc."), ("MELI", "MercadoLibre Inc."),
    ("MNST", "Monster Beverage"), ("PANW", "Palo Alto Networks"), ("KDP", "Keurig Dr Pepper"),
    ("DXCM", "Dexcom Inc."), ("KHC", "Kraft Heinz Co."), ("AZN", "AstraZeneca PLC"),
    ("AEP", "American Electric Power"), ("ADSK", "Autodesk Inc."), ("BIIB", "Biogen Inc."),
    ("IDXX", "IDEXX Laboratories"), ("EXC", "Exelon Corp."), ("MCHP", "Microchip Technology"),
    ("XEL", "Xcel Energy Inc."), ("LULU", "Lululemon Athletica"), ("CTSH", "Cognizant Technology Solutions"),
    ("WDAY", "Workday Inc."), ("ODFL", "Old Dominion Freight Line"), ("ROST", "Ross Stores Inc."),
    ("DLTR", "Dollar Tree Inc."), ("EA", "Electronic Arts"), ("VRSK", "Verisk Analytics"),
    ("CPRT", "Copart Inc."), ("CSGP", "CoStar Group"), ("FAST", "Fastenal Co."),
    ("CRWD", "CrowdStrike Holdings"), ("BKR", "Baker Hughes Co."), ("PCAR", "PACCAR Inc."),
    ("ANSS", "ANSYS Inc."), ("CEG", "Constellation Energy"), ("DDOG", "Datadog Inc."),
    ("TEAM", "Atlassian Corp."), ("FANG", "Diamondback Energy"), ("ZS", "Zscaler Inc."),
    ("SIRI", "Sirius XM Holdings"), ("ALGN", "Align Technology"), ("JD", "JD.com Inc."),
    ("EBAY", "eBay Inc."), ("VOD", "Vodafone Group"), ("WBD", "Warner Bros Discovery"),
    ("RIVN", "Rivian Automotive"), ("ZS", "Zscaler Inc."), ("LCID", "Lucid Group Inc.")
]

# S&P 500 (Top 100 entreprises)
SP500 = [
    ("AAPL", "Apple Inc."), ("MSFT", "Microsoft Corp."), ("AMZN", "Amazon.com Inc."),
    ("GOOGL", "Alphabet Inc."), ("GOOG", "Alphabet Inc. C"), ("META", "Meta Platforms Inc."),
    ("TSLA", "Tesla Inc."), ("NVDA", "NVIDIA Corp."), ("BRK-B", "Berkshire Hathaway"),
    ("JNJ", "Johnson & Johnson"), ("V", "Visa Inc."), ("JPM", "JPMorgan Chase & Co."),
    ("WMT", "Walmart Inc."), ("PG", "Procter & Gamble"), ("UNH", "UnitedHealth Group"),
    ("DIS", "Walt Disney Co."), ("HD", "Home Depot Inc."), ("PYPL", "PayPal Holdings"),
    ("NFLX", "Netflix Inc."), ("ADBE", "Adobe Inc."), ("CRM", "Salesforce.com"),
    ("INTC", "Intel Corp."), ("CSCO", "Cisco Systems"), ("PFE", "Pfizer Inc."),
    ("ABT", "Abbott Laboratories"), ("T", "AT&T Inc."), ("VZ", "Verizon Communications"),
    ("KO", "Coca-Cola Co."), ("PEP", "PepsiCo Inc."), ("XOM", "Exxon Mobil Corp."),
    ("CVX", "Chevron Corp."), ("MRK", "Merck & Co."), ("LLY", "Eli Lilly & Co."),
    ("AVGO", "Broadcom Inc."), ("TMO", "Thermo Fisher Scientific"), ("ABBV", "AbbVie Inc."),
    ("ACN", "Accenture PLC"), ("DHR", "Danaher Corp."), ("WFC", "Wells Fargo & Co."),
    ("NKE", "Nike Inc."), ("PM", "Philip Morris International"), ("TXN", "Texas Instruments"),
    ("COST", "Costco Wholesale"), ("UPS", "United Parcel Service"), ("NEE", "NextEra Energy"),
    ("RTX", "Raytheon Technologies"), ("HON", "Honeywell International"), ("IBM", "International Business Machines"),
    ("AMD", "Advanced Micro Devices"), ("SBUX", "Starbucks Corp."), ("AMGN", "Amgen Inc."),
    ("MDT", "Medtronic PLC"), ("SPGI", "S&P Global Inc."), ("LOW", "Lowe's Companies"),
    ("CAT", "Caterpillar Inc."), ("GS", "Goldman Sachs Group"), ("AXP", "American Express Co."),
    ("PLD", "Prologis Inc."), ("DE", "Deere & Co."), ("BA", "Boeing Co."),
    ("UNP", "Union Pacific Corp."), ("NOW", "ServiceNow Inc."), ("TGT", "Target Corp."),
    ("ISRG", "Intuitive Surgical"), ("SYK", "Stryker Corp."), ("LMT", "Lockheed Martin Corp."),
    ("INTU", "Intuit Inc."), ("ADI", "Analog Devices"), ("MDLZ", "Mondelez International"),
    ("CB", "Chubb Ltd."), ("C", "Citigroup Inc."), ("BLK", "BlackRock Inc."),
    ("AMT", "American Tower Corp."), ("MO", "Altria Group Inc."), ("SCHW", "Charles Schwab Corp."),
    ("CI", "Cigna Corp."), ("ZTS", "Zoetis Inc."), ("MMC", "Marsh & McLennan Companies"),
    ("PNC", "PNC Financial Services"), ("DUK", "Duke Energy Corp."), ("SO", "Southern Co."),
    ("BDX", "Becton Dickinson & Co."), ("BSX", "Boston Scientific Corp."), ("CL", "Colgate-Palmolive Co."),
    ("APD", "Air Products & Chemicals"), ("NOC", "Northrop Grumman Corp."), ("AON", "Aon PLC"),
    ("MCO", "Moody's Corp."), ("EOG", "EOG Resources"), ("CME", "CME Group Inc."),
    ("ICE", "Intercontinental Exchange"), ("SHW", "Sherwin-Williams Co."), ("WM", "Waste Management Inc."),
    ("GD", "General Dynamics Corp."), ("FIS", "Fidelity National Information Services"), ("ITW", "Illinois Tool Works")
]

# Actions europ√©ennes suppl√©mentaires
EUROPE_EXTENDED = [
    ("ASML.AS", "ASML Holding NV"), ("SAF.PA", "Safran SA"), ("SAN.PA", "Sanofi SA"),
    ("OR.PA", "L'Oreal SA"), ("AI.PA", "Air Liquide SA"), ("SU.PA", "Schneider Electric SE"),
    ("AIR.PA", "Airbus SE"), ("MC.PA", "LVMH Moet Hennessy"), ("ADS.DE", "Adidas AG"),
    ("ALV.DE", "Allianz SE"), ("BAS.DE", "BASF SE"), ("BAYN.DE", "Bayer AG"),
    ("BMW.DE", "BMW AG"), ("CON.DE", "Continental AG"), ("DAI.DE", "Daimler Truck Holding"),
    ("DBK.DE", "Deutsche Bank AG"), ("DB1.DE", "Deutsche Boerse AG"), ("DPW.DE", "Deutsche Post AG"),
    ("DTE.DE", "Deutsche Telekom AG"), ("EOAN.DE", "E.ON SE"), ("FME.DE", "Fresenius Medical Care AG"),
    ("FRE.DE", "Fresenius SE & Co KGaA"), ("HEI.DE", "HeidelbergCement AG"), ("HEN3.DE", "Henkel AG & Co KGaA"),
    ("IFX.DE", "Infineon Technologies AG"), ("LIN.DE", "Linde PLC"), ("MRK.DE", "Merck KGaA"),
    ("MUV2.DE", "Munich Re AG"), ("RWE.DE", "RWE AG"), ("SAP.DE", "SAP SE"),
    ("SIE.DE", "Siemens AG"), ("VOW3.DE", "Volkswagen AG"), ("ENEL.MI", "Enel SpA"),
    ("ENI.MI", "Eni SpA"), ("ISP.MI", "Intesa Sanpaolo SpA"), ("STM.MI", "STMicroelectronics NV"),
    ("TIT.MI", "Telecom Italia SpA"), ("UBI.MI", "UniCredit SpA"), ("NOVOb.CO", "Novo Nordisk A/S"),
    ("VWS.CO", "Vestas Wind Systems A/S"), ("AZN.L", "AstraZeneca PLC"), ("GSK.L", "GlaxoSmithKline PLC"),
    ("HSBA.L", "HSBC Holdings PLC"), ("BP.L", "BP PLC"), ("RDSA.L", "Royal Dutch Shell PLC"),
    ("ULVR.L", "Unilever PLC"), ("DGE.L", "Diageo PLC"), ("RIO.L", "Rio Tinto PLC"),
    ("BARC.L", "Barclays PLC"), ("LLOY.L", "Lloyds Banking Group PLC"), ("NG.L", "National Grid PLC"),
    ("TSCO.L", "Tesco PLC"), ("VOD.L", "Vodafone Group PLC"), ("BATS.L", "British American Tobacco PLC")
]

# Cryptomonnaies et ETFs
CRYPTO_ETFS = [
    ("BTC-USD", "Bitcoin USD"), ("ETH-USD", "Ethereum USD"), ("ADA-USD", "Cardano USD"),
    ("DOT-USD", "Polkadot USD"), ("LTC-USD", "Litecoin USD"), ("XRP-USD", "Ripple USD"),
    ("BCH-USD", "Bitcoin Cash USD"), ("LINK-USD", "Chainlink USD"), ("UNI-USD", "Uniswap USD"),
    ("DOGE-USD", "Dogecoin USD"), ("SOL-USD", "Solana USD"), ("AVAX-USD", "Avalanche USD"),
    ("MATIC-USD", "Polygon USD"), ("ATOM-USD", "Cosmos USD"), ("ALGO-USD", "Algorand USD"),
    ("SPY", "SPDR S&P 500 ETF"), ("QQQ", "Invesco QQQ Trust"), ("IWM", "iShares Russell 2000 ETF"),
    ("EEM", "iShares MSCI Emerging Markets ETF"), ("VGK", "Vanguard FTSE Europe ETF"),
    ("VOO", "Vanguard S&P 500 ETF"), ("IVV", "iShares Core S&P 500 ETF"), ("DIA", "SPDR Dow Jones Industrial Average ETF")
]

# Combiner toutes les actions
ALL_STOCKS = CAC40 + SBF120 + DOW_JONES + NASDAQ100 + SP500 + EUROPE_EXTENDED + CRYPTO_ETFS
# Supprimer les doublons
ALL_STOCKS = list(dict.fromkeys(ALL_STOCKS))

# Dictionnaire des indices
INDICES = {
    "CAC40": CAC40,
    "SBF120": SBF120, 
    "Dow Jones": DOW_JONES,
    "NASDAQ100": NASDAQ100,
    "S&P500": SP500,
    "Europe √©tendu": EUROPE_EXTENDED,
    "Crypto & ETFs": CRYPTO_ETFS,
    "TOUTES LES ACTIONS": ALL_STOCKS
}

# ---------------------------------------------------------------------
# SYST√àME DE FAVORIS AM√âLIOR√â
# ---------------------------------------------------------------------
def init_favoris():
    """Initialise la liste des favoris dans le session state"""
    if 'favoris' not in st.session_state:
        st.session_state.favoris = []
    if 'last_analyzed' not in st.session_state:
        st.session_state.last_analyzed = None

def toggle_favori(symbol, name):
    """Ajoute ou retire un favori"""
    init_favoris()
    favori_item = (symbol, name)
    
    if favori_item in st.session_state.favoris:
        st.session_state.favoris.remove(favori_item)
        st.success(f"‚ùå {name} retir√© des favoris")
    else:
        st.session_state.favoris.append(favori_item)
        st.success(f"‚≠ê {name} ajout√© aux favoris")
    
    # Forcer le rerun pour mettre √† jour l'interface
    st.rerun()

# ---------------------------------------------------------------------
# SCANNER TRADING (TOUS LES INDICES)
# ---------------------------------------------------------------------
def run_scanner():
    st.markdown("### üîç Scanner Trading")
    
    # Initialisation du session state
    if 'scan_results' not in st.session_state:
        st.session_state.scan_results = None
    if 'scan_done' not in st.session_state:
        st.session_state.scan_done = False
    if 'selected_index' not in st.session_state:
        st.session_state.selected_index = "CAC40"
    
    st.info("""
    **üéØ R√®gle LineBreak :** D√©tection des actions o√π les **2 derni√®res briques LineBreak alternent** 
    - üî¥ ‚Üí üü¢ **ROUGE puis VERT** = Tendance haussi√®re
    - üü¢ ‚Üí üî¥ **VERT puis ROUGE** = Tendance baissi√®re
    - **P√©riode :** 3 mois ‚Ä¢ **Reversal :** 2 briques
    """)
    
    # Options indicateurs seulement
    st.sidebar.markdown("### üìä Options indicateurs")
    show_bollinger = st.sidebar.checkbox("Bandes de Bollinger", value=True, key="boll_scanner")
    show_ema = st.sidebar.checkbox("EMA 20 (courbe de tendance)", value=True, key="ema_scanner")
    show_macd = st.sidebar.checkbox("MACD", value=True, key="macd_scanner")
    auto_display = st.sidebar.checkbox("Afficher graphiques auto", value=False, key="auto_scanner")
    
    # S√©lection de l'indice dans la sidebar
    st.sidebar.markdown("### üìà Indice √† scanner")
    selected_index = st.sidebar.selectbox(
        "Choisir l'indice:",
        list(INDICES.keys()),
        key="index_selector_scanner"
    )
    
    # Bouton de scan dans la sidebar
    if st.sidebar.button("üöÄ Lancer le scan", key="scan_trading_main") or not st.session_state.scan_done:
        st.session_state.selected_index = selected_index
        perform_scan(selected_index)
    
    # Afficher les r√©sultats si disponibles
    if st.session_state.scan_results is not None:
        display_scan_results(st.session_state.scan_results, show_bollinger, show_ema, show_macd, auto_display, selected_index)

def perform_scan(selected_index):
    """Effectue le scan et stocke les r√©sultats"""
    stocks_list = INDICES[selected_index]
    hits = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, (symbol, name) in enumerate(stocks_list):
        status_text.text(f"üîç Analyse de {name}...")
        progress_bar.progress((i + 1) / len(stocks_list))
        
        try:
            # P√©riode FIXE 3mo pour LineBreak
            df = get_clean_data(symbol, "3mo")
            if df is not None and len(df) > 20:
                signal_detected, bricks = detect_boursorama_signal(df)
                if signal_detected:
                    hits.append((symbol, name, df, bricks))
        except Exception as e:
            continue
    
    progress_bar.empty()
    status_text.empty()
    
    # Stocker les r√©sultats dans session state
    st.session_state.scan_results = hits
    st.session_state.scan_done = True

def display_scan_results(hits, show_bollinger, show_ema, show_macd, auto_display, selected_index):
    """Affiche les r√©sultats du scan avec interactivit√©"""
    if hits:
        st.success(f"**{len(hits)} signal(s) d√©tect√©(s) dans le {selected_index}**")
        
        for symbol, name, df, bricks in hits:
            # D√©terminer le type de signal
            last_two = bricks[-2:]
            if last_two and last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
                signal_type = "üî¥ ‚Üí üü¢ ROUGE ‚Üí VERT"
                signal_emoji = "üî¥üü¢"
                signal_direction = "HAUSSE"
            else:
                signal_type = "üü¢ ‚Üí üî¥ VERT ‚Üí ROUGE" 
                signal_emoji = "üü¢üî¥"
                signal_direction = "BAISSE"
            
            with st.expander(f"{signal_emoji} {name} ({symbol}) - {signal_type} - {signal_direction}", expanded=auto_display):
                
                # Bouton favori
                col_btn1, col_btn2 = st.columns([1, 4])
                with col_btn1:
                    is_favori = (symbol, name) in st.session_state.get('favoris', [])
                    favori_text = "‚ùå Retirer des favoris" if is_favori else "‚≠ê Ajouter aux favoris"
                    if st.button(favori_text, key=f"fav_{symbol}_{name}"):
                        toggle_favori(symbol, name)
                
                # M√©triques avec v√©rification de l'actualisation
                current_price = df['Close'].iloc[-1]
                prev_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
                change = current_price - prev_price
                change_pct = (change / prev_price) * 100
                
                # V√©rifier si les donn√©es sont √† jour
                last_data_date = df.index[-1].date()
                today = datetime.now().date()
                is_up_to_date = (today - last_data_date).days <= 1
                
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%")
                col2.metric("Variation", f"{change:+.2f}")
                
                # Afficher la date avec un indicateur d'actualisation
                date_display = df.index[-1].strftime("%d/%m/%Y")
                if not is_up_to_date:
                    date_display += " ‚ö†Ô∏è"
                col3.metric("Derni√®re MAJ", date_display)
                
                col4.metric("Signal", signal_direction)
                
                if not is_up_to_date:
                    st.warning(f"‚ö†Ô∏è Les donn√©es de {name} ne sont pas √† jour. Derni√®re date: {df.index[-1].strftime('%d/%m/%Y')}")
                
                # Graphiques avec option de p√©riode pour le graphique complet seulement
                st.markdown("#### üìä Graphiques")
                
                # S√©lecteur de p√©riode pour le graphique complet avec interactivit√©
                chart_period = st.selectbox(
                    f"P√©riode pour {name}",
                    ["1mo", "3mo", "6mo", "1y"],
                    index=1,
                    key=f"chart_period_{symbol}_{name}"
                )
                
                # R√©cup√©rer donn√©es pour la p√©riode choisie
                df_chart = get_clean_data(symbol, chart_period)
                
                tab1, tab2 = st.tabs(["üìà Graphique Complet", "üß± LineBreak (3 mois)"])
                
                with tab1:
                    if df_chart is not None:
                        st.plotly_chart(
                            create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                            use_container_width=True,
                            key=f"chart_{symbol}_{name}_{chart_period}"
                        )
                    else:
                        st.error("Donn√©es non disponibles pour cette p√©riode")
                
                with tab2:
                    lb_chart = create_linebreak_chart(df, bricks, f"{name} - LineBreak (3 mois)")
                    if lb_chart:
                        st.plotly_chart(lb_chart, use_container_width=True, key=f"lb_{symbol}_{name}")
                    else:
                        st.warning("Donn√©es LineBreak insuffisantes")
    
    else:
        st.info(f"ü§ñ Aucune alternance d√©tect√©e dans le {selected_index} pour le moment.")
        st.caption("üí° _Les signaux LineBreak sont rares - c'est normal d'en avoir peu_")

# ---------------------------------------------------------------------
# SCANNER FAVORIS COMPLET AVEC SCAN
# ---------------------------------------------------------------------
def run_favoris():
    st.markdown("### ‚≠ê Scanner Favoris")
    
    init_favoris()
    
    if not st.session_state.favoris:
        st.info("üåü Aucun favori ajout√©. Utilisez le scanner Trading pour ajouter des actions √† vos favoris.")
        return
    
    st.info(f"**üìä {len(st.session_state.favoris)} action(s) dans les favoris**")
    
    # Options indicateurs
    st.sidebar.markdown("### üìä Options indicateurs")
    show_bollinger = st.sidebar.checkbox("Bandes de Bollinger", value=True, key="boll_fav")
    show_ema = st.sidebar.checkbox("EMA 20 (courbe de tendance)", value=True, key="ema_fav")
    show_macd = st.sidebar.checkbox("MACD", value=True, key="macd_fav")
    auto_display_fav = st.sidebar.checkbox("Afficher graphiques auto", value=False, key="auto_fav")
    
    # BOUTON DE SCAN DANS LA SIDEBAR POUR LES FAVORIS
    if st.sidebar.button("üöÄ Scanner les favoris", key="scan_favoris_main"):
        st.session_state.favoris_mode = "scan"
        st.rerun()
    
    # CHOIX DU MODE : Scan des signaux ou Tous les favoris
    mode_favoris = st.radio(
        "Mode d'affichage:",
        ["üîç Scanner les favoris", "‚≠ê Tous mes favoris"],
        horizontal=True,
        key="mode_favoris_main"
    )
    
    if mode_favoris == "üîç Scanner les favoris":
        # Scanner des favoris avec d√©tection de signaux
        scan_favoris(show_bollinger, show_ema, show_macd, auto_display_fav)
    else:
        # Affichage de tous les favoris
        display_all_favoris(show_bollinger, show_ema, show_macd, auto_display_fav)

def scan_favoris(show_bollinger, show_ema, show_macd, auto_display):
    """Scan des favoris pour d√©tecter les signaux LineBreak"""
    if not st.session_state.favoris:
        return
    
    # Scanner les favoris pour trouver les signaux
    hits = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, (symbol, name) in enumerate(st.session_state.favoris):
        status_text.text(f"üîç Scan de {name}...")
        progress_bar.progress((i + 1) / len(st.session_state.favoris))
        
        try:
            # P√©riode FIXE 3mo pour LineBreak
            df = get_clean_data(symbol, "3mo")
            if df is not None and len(df) > 20:
                signal_detected, bricks = detect_boursorama_signal(df)
                if signal_detected:
                    hits.append((symbol, name, df, bricks))
        except Exception as e:
            continue
    
    progress_bar.empty()
    status_text.empty()
    
    if hits:
        st.success(f"**üéØ {len(hits)} signal(s) d√©tect√©(s) parmi vos favoris**")
        
        for symbol, name, df, bricks in hits:
            # D√©terminer le type de signal
            last_two = bricks[-2:]
            if last_two and last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
                signal_type = "üî¥ ‚Üí üü¢ ROUGE ‚Üí VERT"
                signal_emoji = "üî¥üü¢"
                signal_direction = "HAUSSE"
            else:
                signal_type = "üü¢ ‚Üí üî¥ VERT ‚Üí ROUGE" 
                signal_emoji = "üü¢üî¥"
                signal_direction = "BAISSE"
            
            with st.expander(f"{signal_emoji} {name} ({symbol}) - {signal_type} - {signal_direction}", expanded=auto_display):
                
                # Bouton retirer favori
                if st.button("‚ùå Retirer des favoris", key=f"remove_fav_{symbol}_{name}"):
                    toggle_favori(symbol, name)
                
                # M√©triques avec v√©rification de l'actualisation
                current_price = df['Close'].iloc[-1]
                prev_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
                change = current_price - prev_price
                change_pct = (change / prev_price) * 100
                
                # V√©rifier si les donn√©es sont √† jour
                last_data_date = df.index[-1].date()
                today = datetime.now().date()
                is_up_to_date = (today - last_data_date).days <= 1
                
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%")
                col2.metric("Variation", f"{change:+.2f}")
                
                # Afficher la date avec un indicateur d'actualisation
                date_display = df.index[-1].strftime("%d/%m/%Y")
                if not is_up_to_date:
                    date_display += " ‚ö†Ô∏è"
                col3.metric("Derni√®re MAJ", date_display)
                
                col4.metric("Signal", signal_direction)
                
                if not is_up_to_date:
                    st.warning(f"‚ö†Ô∏è Les donn√©es de {name} ne sont pas √† jour. Derni√®re date: {df.index[-1].strftime('%d/%m/%Y')}")
                
                # Graphiques avec option de p√©riode
                st.markdown("#### üìä Graphiques")
                
                # S√©lecteur de p√©riode pour le graphique complet
                chart_period = st.selectbox(
                    f"P√©riode pour {name}",
                    ["1mo", "3mo", "6mo", "1y"],
                    index=1,
                    key=f"scan_period_{symbol}_{name}"
                )
                
                # R√©cup√©rer donn√©es pour la p√©riode choisie
                df_chart = get_clean_data(symbol, chart_period)
                
                tab1, tab2 = st.tabs(["üìà Graphique Complet", "üß± LineBreak (3 mois)"])
                
                with tab1:
                    if df_chart is not None:
                        st.plotly_chart(
                            create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                            use_container_width=True,
                            key=f"scan_chart_{symbol}_{name}_{chart_period}"
                        )
                    else:
                        st.error("Donn√©es non disponibles pour cette p√©riode")
                
                with tab2:
                    if bricks:
                        lb_chart = create_linebreak_chart(df, bricks, f"{name} - LineBreak (3 mois)")
                        if lb_chart:
                            st.plotly_chart(lb_chart, use_container_width=True, key=f"scan_lb_{symbol}_{name}")
                        else:
                            st.warning("Donn√©es LineBreak insuffisantes")
                    else:
                        st.info("Aucune brique LineBreak disponible")
    
    else:
        st.info("ü§ñ Aucun signal d√©tect√© parmi vos favoris pour le moment.")
        st.caption("üí° _Les signaux LineBreak sont rares - surveillez r√©guli√®rement vos favoris_")

def display_all_favoris(show_bollinger, show_ema, show_macd, auto_display):
    """Affiche tous les favoris avec leurs graphiques complets"""
    if not st.session_state.favoris:
        return
    
    # Analyser tous les favoris
    favoris_data = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, (symbol, name) in enumerate(st.session_state.favoris):
        status_text.text(f"üìä Chargement de {name}...")
        progress_bar.progress((i + 1) / len(st.session_state.favoris))
        
        try:
            # P√©riode FIXE 3mo pour LineBreak
            df = get_clean_data(symbol, "3mo")
            if df is not None and len(df) > 20:
                signal_detected, bricks = detect_boursorama_signal(df)
                favoris_data.append((symbol, name, df, bricks, signal_detected))
        except Exception as e:
            continue
    
    progress_bar.empty()
    status_text.empty()
    
    # Afficher tous les favoris
    for symbol, name, df, bricks, signal_detected in favoris_data:
        # D√©terminer le type de signal
        if signal_detected and bricks and len(bricks) >= 2:
            last_two = bricks[-2:]
            if last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
                signal_type = "üî¥ ‚Üí üü¢ ROUGE ‚Üí VERT"
                signal_emoji = "üî¥üü¢"
                signal_direction = "HAUSSE"
            else:
                signal_type = "üü¢ ‚Üí üî¥ VERT ‚Üí ROUGE" 
                signal_emoji = "üü¢üî¥"
                signal_direction = "BAISSE"
        else:
            signal_type = "Aucun signal"
            signal_emoji = "‚ö™"
            signal_direction = "NEUTRE"
        
        with st.expander(f"{signal_emoji} {name} ({symbol}) - {signal_type} - {signal_direction}", expanded=auto_display):
            
            # Bouton retirer favori
            if st.button("‚ùå Retirer des favoris", key=f"remove_fav_all_{symbol}_{name}"):
                toggle_favori(symbol, name)
            
            # M√©triques avec v√©rification de l'actualisation
            current_price = df['Close'].iloc[-1]
            prev_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
            change = current_price - prev_price
            change_pct = (change / prev_price) * 100
            
            # V√©rifier si les donn√©es sont √† jour
            last_data_date = df.index[-1].date()
            today = datetime.now().date()
            is_up_to_date = (today - last_data_date).days <= 1
            
            col1, col2, col3, col4 = st.columns(4)
            col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%")
            col2.metric("Variation", f"{change:+.2f}")
            
            # Afficher la date avec un indicateur d'actualisation
            date_display = df.index[-1].strftime("%d/%m/%Y")
            if not is_up_to_date:
                date_display += " ‚ö†Ô∏è"
            col3.metric("Derni√®re MAJ", date_display)
            
            col4.metric("Signal", signal_direction)
            
            if not is_up_to_date:
                st.warning(f"‚ö†Ô∏è Les donn√©es de {name} ne sont pas √† jour. Derni√®re date: {df.index[-1].strftime('%d/%m/%Y')}")
            
            # Graphiques avec option de p√©riode
            st.markdown("#### üìä Graphiques")
            
            # S√©lecteur de p√©riode pour le graphique complet
            chart_period = st.selectbox(
                f"P√©riode pour {name}",
                ["1mo", "3mo", "6mo", "1y"],
                index=1,
                key=f"fav_period_{symbol}_{name}"
            )
            
            # R√©cup√©rer donn√©es pour la p√©riode choisie
            df_chart = get_clean_data(symbol, chart_period)
            
            tab1, tab2 = st.tabs(["üìà Graphique Complet", "üß± LineBreak (3 mois)"])
            
            with tab1:
                if df_chart is not None:
                    st.plotly_chart(
                        create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                        use_container_width=True,
                        key=f"fav_chart_{symbol}_{name}_{chart_period}"
                    )
                else:
                    st.error("Donn√©es non disponibles pour cette p√©riode")
            
            with tab2:
                if bricks:
                    lb_chart = create_linebreak_chart(df, bricks, f"{name} - LineBreak (3 mois)")
                    if lb_chart:
                        st.plotly_chart(lb_chart, use_container_width=True, key=f"fav_lb_{symbol}_{name}")
                    else:
                        st.warning("Donn√©es LineBreak insuffisantes")
                else:
                    st.info("Aucune brique LineBreak disponible")

# ---------------------------------------------------------------------
# ANALYSE INDIVIDUELLE AM√âLIOR√âE (TOUTES LES ACTIONS)
# ---------------------------------------------------------------------
def run_individual_analysis():
    st.markdown("### üîç Analyse Individuelle")
    
    # Mode de s√©lection : liste pr√©d√©finie OU saisie libre
    selection_mode = st.radio(
        "Mode de s√©lection:",
        ["üìã Liste pr√©d√©finie", "üîç Recherche libre"],
        horizontal=True,
        key="selection_mode_main"
    )
    
    # Options indicateurs dans la sidebar - UNIQUEMENT ICI
    st.sidebar.markdown("### üìä Options indicateurs")
    show_bollinger = st.sidebar.checkbox("Bandes de Bollinger", value=True, key="boll_indiv_unique")
    show_ema = st.sidebar.checkbox("EMA 20 (courbe de tendance)", value=True, key="ema_indiv_unique") 
    show_macd = st.sidebar.checkbox("MACD", value=True, key="macd_indiv_unique")
    
    # S√©lecteur de p√©riode pour l'analyse individuelle
    st.sidebar.markdown("### ‚è∞ P√©riode graphique")
    chart_period = st.sidebar.selectbox(
        "P√©riode affichage",
        ["1mo", "3mo", "6mo", "1y"],
        index=1,
        key="period_indiv_unique"
    )
    
    if selection_mode == "üìã Liste pr√©d√©finie":
        # Combiner toutes les actions de tous les indices
        all_stocks = []
        for index_name, stocks in INDICES.items():
            for symbol, name in stocks:
                all_stocks.append((symbol, name, index_name))
        
        # Stocker l'action s√©lectionn√©e dans le session state
        if 'selected_stock' not in st.session_state:
            st.session_state.selected_stock = f"{all_stocks[0][1]} ({all_stocks[0][0]}) - {all_stocks[0][2]}"
        
        selected_stock = st.selectbox(
            "Choisir une action:",
            [f"{name} ({symbol}) - {index_name}" for symbol, name, index_name in all_stocks],
            index=0,
            key="stock_selector_predefined"
        )
        
        # Extraire le symbole et le nom
        symbol = selected_stock.split("(")[1].split(")")[0]
        name = selected_stock.split("(")[0].strip()
        
    else:  # Mode recherche libre
        st.info("üí° **Recherche libre** : Choisissez parmi 500+ actions mondiales ou saisissez un symbole manuellement")
        
        # Utiliser TOUTES les actions pour la recherche libre
        all_stocks_free = ALL_STOCKS
        
        # Trier par nom pour faciliter la recherche
        all_stocks_free.sort(key=lambda x: x[1])
        
        # S√©lecteur avec recherche pour la recherche libre
        if 'selected_free_stock' not in st.session_state:
            st.session_state.selected_free_stock = f"{all_stocks_free[0][1]} ({all_stocks_free[0][0]})"
        
        selected_free_stock = st.selectbox(
            "Choisir une action:",
            [f"{name} ({symbol})" for symbol, name in all_stocks_free],
            index=0,
            key="free_stock_selector_search"
        )
        
        # Extraire le symbole et le nom
        symbol = selected_free_stock.split("(")[1].split(")")[0]
        name = selected_free_stock.split("(")[0].strip()
    
    # Stocker la derni√®re action analys√©e
    st.session_state.last_analyzed = (symbol, name)
    
    # AFFICHAGE DE L'ANALYSE
    display_individual_analysis(symbol, name, chart_period, show_bollinger, show_ema, show_macd)

def display_individual_analysis(symbol, name, chart_period, show_bollinger, show_ema, show_macd):
    """Affiche l'analyse pour une action donn√©e (utilis√© par les deux modes)"""
    
    # Donn√©es pour LineBreak (3mo FIXE)
    df_lb = get_clean_data(symbol, "3mo")
    # Donn√©es pour graphique complet (p√©riode choisie)
    df_chart = get_clean_data(symbol, chart_period)
    
    if df_lb is None or df_lb.empty:
        st.error(f"‚ùå Donn√©es non disponibles pour {symbol}")
        st.info("üí° V√©rifiez que le symbole est correct et existe sur Yahoo Finance")
        return
    
    signal_detected, bricks = detect_boursorama_signal(df_lb)
    
    # Bouton favori - AM√âLIOR√â
    is_favori = (symbol, name) in st.session_state.get('favoris', [])
    favori_text = "‚ùå Retirer des favoris" if is_favori else "‚≠ê Ajouter aux favoris"
    fav_col1, fav_col2 = st.columns([1, 5])
    with fav_col1:
        if st.button(favori_text, key=f"fav_indiv_{symbol}_{name}", type="primary" if not is_favori else "secondary"):
            toggle_favori(symbol, name)
    
    # M√©triques avec v√©rification de l'actualisation
    current_price = df_lb['Close'].iloc[-1]
    prev_price = df_lb['Close'].iloc[-2] if len(df_lb) > 1 else current_price
    change = current_price - prev_price
    change_pct = (change / prev_price) * 100
    
    # V√©rifier si les donn√©es sont √† jour
    last_data_date = df_lb.index[-1].date()
    today = datetime.now().date()
    is_up_to_date = (today - last_data_date).days <= 1
    
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%", key=f"price_{symbol}")
    col2.metric("Variation", f"{change:+.2f}", key=f"change_{symbol}")
    
    # Afficher la date avec un indicateur d'actualisation
    date_display = df_lb.index[-1].strftime("%d/%m/%Y")
    if not is_up_to_date:
        date_display += " ‚ö†Ô∏è"
    col3.metric("Derni√®re MAJ", date_display, key=f"date_{symbol}")
    
    if signal_detected and bricks and len(bricks) >= 2:
        last_two = bricks[-2:]
        if last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
            signal_type = "üî¥ ‚Üí üü¢ ROUGE ‚Üí VERT"
            signal_direction = "HAUSSE"
        else:
            signal_type = "üü¢ ‚Üí üî¥ VERT ‚Üí ROUGE"
            signal_direction = "BAISSE"
        col4.metric("Signal", signal_direction, key=f"signal_{symbol}")
        st.success(f"üéØ **{signal_type} d√©tect√© !** - Signal {signal_direction}")
    else:
        col4.metric("Signal", "Aucun", key=f"signal_none_{symbol}")
        st.info("ü§ñ Aucune alternance d√©tect√©e")
    
    if not is_up_to_date:
        st.warning(f"‚ö†Ô∏è Les donn√©es de {name} ne sont pas √† jour. Derni√®re date: {df_lb.index[-1].strftime('%d/%m/%Y')}")
        st.info("üí° Utilisez le bouton 'Actualiser toutes les donn√©es' dans la sidebar pour forcer l'actualisation")
    
    # Graphiques
    tab1, tab2 = st.tabs(["üìà Graphique Complet", "üß± LineBreak (3 mois)"])
    
    with tab1:
        if df_chart is not None and not df_chart.empty:
            st.plotly_chart(
                create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                use_container_width=True,
                key=f"indiv_chart_{symbol}_{name}_{chart_period}"
            )
        else:
            st.error("Donn√©es non disponibles pour cette p√©riode")
    
    with tab2:
        if bricks:
            lb_chart = create_linebreak_chart(df_lb, bricks, f"{name} - LineBreak (3 mois)")
            if lb_chart:
                st.plotly_chart(lb_chart, use_container_width=True, key=f"indiv_lb_{symbol}_{name}")
            else:
                st.warning("Donn√©es LineBreak insuffisantes")
        else:
            st.info("Aucune brique LineBreak disponible")

# ---------------------------------------------------------------------
# INTERFACE PRINCIPALE
# ---------------------------------------------------------------------
def main():
    st.sidebar.title("Navigation")
    app_mode = st.sidebar.selectbox(
        "Choisir le mode:",
        ["Scanner Trading", "Analyse Individuelle", "‚≠ê Favoris", "Analyse Technique"],
        key="main_navigation"
    )
    
    # Initialisation des favoris
    init_favoris()
    
    # Bouton d'actualisation g√©n√©ral dans la sidebar
    st.sidebar.markdown("---")
    if st.sidebar.button("üîÑ Actualiser toutes les donn√©es", type="secondary", key="refresh_all_data"):
        st.cache_data.clear()
        # R√©initialiser tous les √©tats sauf les favoris et last_analyzed
        favoris_backup = st.session_state.get('favoris', [])
        last_analyzed_backup = st.session_state.get('last_analyzed', None)
        for key in list(st.session_state.keys()):
            if key not in ['favoris', 'last_analyzed']:
                del st.session_state[key]
        st.session_state.favoris = favoris_backup
        st.session_state.last_analyzed = last_analyzed_backup
        st.rerun()
    
    if app_mode == "Scanner Trading":
        run_scanner()
    elif app_mode == "Analyse Individuelle":
        run_individual_analysis()
    elif app_mode == "‚≠ê Favoris":
        run_favoris()
    else:
        st.markdown("""
        ## üìä Analyse Technique

        ### üß± LineBreak
        **R√®gles de trading :**
        - üî¥ ‚Üí üü¢ **ROUGE puis VERT** = Tendance haussi√®re
        - üü¢ ‚Üí üî¥ **VERT puis ROUGE** = Tendance baissi√®re

        **Combinaison de signaux :**
        - ‚úÖ **LineBreak rouge‚Üívert** + ‚úÖ **Cours touche bande Bollinger basse** + ‚û°Ô∏è **Courbe tendance neutre/hausse** = üìà Signal haussier renforc√©
        - ‚úÖ **LineBreak vert‚Üírouge** + ‚úÖ **Cours touche bande Bollinger haute** + ‚û°Ô∏è **Courbe tendance neutre/baisse** = üìâ Signal baissier renforc√©

        ### üìà Indicateurs Techniques Int√©gr√©s

        **Bandes de Bollinger**
        - **Calcul :** Moyenne mobile 20 jours + 2 √©carts-types
        - **Bande sup√©rieure =** SMA20 + (2 √ó √©cart-type)
        - **Bande inf√©rieure =** SMA20 - (2 √ó √©cart-type)
        - **Utilit√© :** Rep√©rer les niveaux de surachat/survente

        **EMA 20 (courbe de tendance)**
        - **Calcul :** Moyenne mobile exponentielle sur 20 jours
        - **Formule :** EMA = (Prix √ó Œ±) + (EMA_pr√©c√©dent √ó (1-Œ±)) o√π Œ± = 2/(20+1)
        - **Interpr√©tation :** 
          - Courbe en hausse = tendance haussi√®re
          - Courbe en baisse = tendance baissi√®re  
          - Courbe plate = tendance neutre

        **MACD**
        - **Calcul :** EMA12 - EMA26 (ligne MACD)
        - **Ligne de signal :** EMA9 du MACD
        - **Histogramme :** MACD - ligne de signal
        - **Interpr√©tation :**
          - Au-dessus de 0 = tendance haussi√®re
          - En-dessous de 0 = tendance baissi√®re
          - Ligne MACD croise ligne de signal = changement de momentum

        ### üîÑ Fonctionnalit√©s Interactives
        - Scan automatique du CAC40, SBF120, Dow Jones, NASDAQ100, S&P500 et plus
        - Syst√®me de favoris avec analyse compl√®te
        - Graphiques interactifs avec dates
        - Actualisation manuelle des donn√©es
        - Indicateurs personnalisables

        *üìà Donn√©es Yahoo Finance ‚Ä¢ üéØ Algorithmes professionnels ‚Ä¢ ‚ö†Ô∏è √Ä titre √©ducatif uniquement*

        **‚ö†Ô∏è AVERTISSEMENT :** Ce scanner est un outil d'aide √† la d√©cision. 
        Les performances pass√©es ne pr√©jugent pas des performances futures. 
        Investissez uniquement l'argent que vous pouvez vous permettre de perdre.
        """)

if __name__ == "__main__":
    main()