import re
from typing import Optional
import numpy as np
import pandas as pd
import requests
import streamlit as st
import yfinance as yf
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta

# ---------------------------------------------------------------------
# CONFIG
# ---------------------------------------------------------------------
st.set_page_config(page_title="Scanner Trading", layout="wide")
st.title("ðŸ“ˆ Scanner Trading")

# ---------------------------------------------------------------------
# LINE BREAK CALCUL SELON BOURSORAMA (FIXE)
# ---------------------------------------------------------------------
def calculate_boursorama_linebreak(close_prices, reversal=2):
    """
    Calcul LineBreak selon l'implÃ©mentation Boursorama
    reversal=2 FIXE comme sur Boursorama
    """
    if len(close_prices) < reversal + 1:
        return []
    
    bricks = []
    # PremiÃ¨re brique basÃ©e sur les deux premiers cours
    bricks.append({
        'type': 'green' if close_prices[1] > close_prices[0] else 'red',
        'open': close_prices[0],
        'close': close_prices[1],
        'index': 1
    })
    
    for i in range(2, len(close_prices)):
        current_close = close_prices[i]
        last_brick = bricks[-1]
        
        # RÃˆGLE BOURSORAMA : VÃ©rifier d'abord les inversions
        reversal_occurred = False
        
        if last_brick['type'] == 'green':
            # Inversion si on casse le bas des 2 derniÃ¨res briques vertes
            if len(bricks) >= reversal:
                recent_lows = [bricks[-j]['open'] for j in range(1, min(reversal, len(bricks)) + 1)]
                min_recent_low = min(recent_lows)
                if current_close < min_recent_low:
                    bricks.append({
                        'type': 'red',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
                    reversal_occurred = True
        
        else:  # red brick
            # Inversion si on casse le haut des 2 derniÃ¨res briques rouges
            if len(bricks) >= reversal:
                recent_highs = [bricks[-j]['open'] for j in range(1, min(reversal, len(bricks)) + 1)]
                max_recent_high = max(recent_highs)
                if current_close > max_recent_high:
                    bricks.append({
                        'type': 'green',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
                    reversal_occurred = True
        
        # Si pas d'inversion, continuer la tendance actuelle
        if not reversal_occurred:
            if last_brick['type'] == 'green':
                if current_close > last_brick['close']:
                    bricks.append({
                        'type': 'green',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
            else:  # red
                if current_close < last_brick['close']:
                    bricks.append({
                        'type': 'red',
                        'open': last_brick['close'],
                        'close': current_close,
                        'index': i
                    })
    
    return bricks

def get_clean_data(symbol, period="3mo"):
    """RÃ©cupÃ¨re des donnÃ©es propres avec actualisation complÃ¨te"""
    try:
        # TÃ©lÃ©charger les donnÃ©es avec une pÃ©riode qui garantit l'actualisation
        df = yf.download(symbol, period=period, interval="1d", auto_adjust=True, progress=False)
        if df.empty:
            return None
        
        # Nettoyage
        df = df[['Open', 'High', 'Low', 'Close', 'Volume']].copy()
        df.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
        df = df.dropna()
        
        # CORRECTION : Ne pas ignorer le jour en cours pour avoir les donnÃ©es les plus rÃ©centes
        # VÃ©rifier si les donnÃ©es sont Ã  jour
        last_data_date = df.index[-1].date()
        today = datetime.now().date()
        
        # Si les donnÃ©es ont plus d'1 jour de retard, essayer de forcer l'actualisation
        if (today - last_data_date).days > 1:
            # TÃ©lÃ©charger avec une pÃ©riode diffÃ©rente pour forcer l'actualisation
            df_fresh = yf.download(symbol, period="1mo", interval="1d", auto_adjust=True, progress=False)
            if not df_fresh.empty:
                df_fresh = df_fresh[['Open', 'High', 'Low', 'Close', 'Volume']].copy()
                df_fresh.columns = ['Open', 'High', 'Low', 'Close', 'Volume']
                df_fresh = df_fresh.dropna()
                if len(df_fresh) > 0:
                    df = df_fresh
        
        return df
    except Exception as e:
        st.error(f"Erreur lors du tÃ©lÃ©chargement des donnÃ©es pour {symbol}: {str(e)}")
        return None

def detect_boursorama_signal(df):
    """DÃ©tecte les signaux selon Boursorama avec reversal=2 FIXE"""
    if df is None or len(df) < 10:
        return False, []
    
    close_prices = df['Close'].values
    bricks = calculate_boursorama_linebreak(close_prices, reversal=2)
    
    if len(bricks) < 2:
        return False, bricks
    
    last_two = bricks[-2:]
    signal_detected = (
        (last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green') or
        (last_two[0]['type'] == 'green' and last_two[1]['type'] == 'red')
    )
    
    return signal_detected, bricks

# ---------------------------------------------------------------------
# CALCUL MACD
# ---------------------------------------------------------------------
def calculate_macd(df, fast=12, slow=26, signal=9):
    """Calcule le MACD"""
    df = df.copy()
    
    # EMA rapide et lente
    df['EMA_fast'] = df['Close'].ewm(span=fast).mean()
    df['EMA_slow'] = df['Close'].ewm(span=slow).mean()
    
    # MACD et ligne de signal
    df['MACD'] = df['EMA_fast'] - df['EMA_slow']
    df['MACD_signal'] = df['MACD'].ewm(span=signal).mean()
    df['MACD_histogram'] = df['MACD'] - df['MACD_signal']
    
    return df

# ---------------------------------------------------------------------
# GRAPHIQUES AMÃ‰LIORÃ‰S AVEC MACD ET DATES
# ---------------------------------------------------------------------
def create_pro_chart(df, title, show_bollinger=True, show_ema=True, show_macd=True):
    """Graphique trading professionnel avec MACD"""
    # Calculer le MACD si demandÃ©
    if show_macd:
        df = calculate_macd(df)
    
    if show_macd:
        fig = make_subplots(
            rows=2, cols=1,
            shared_xaxes=True,
            vertical_spacing=0.03,
            subplot_titles=(f"<b>{title}</b>", "<b>MACD</b>"),
            row_heights=[0.7, 0.3]
        )
    else:
        fig = make_subplots(rows=1, cols=1, subplot_titles=(f"<b>{title}</b>",))
    
    # Bougies
    row = 1 if show_macd else 1
    fig.add_trace(go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        increasing_line_color='#00CC00',
        decreasing_line_color='#FF0000',
        name='Prix'
    ), row=row, col=1)
    
    # Bollinger Bands
    if show_bollinger and len(df) > 20:
        df['SMA20'] = df['Close'].rolling(20).mean()
        df['STD20'] = df['Close'].rolling(20).std()
        df['BB_Upper'] = df['SMA20'] + (df['STD20'] * 2)
        df['BB_Lower'] = df['SMA20'] - (df['STD20'] * 2)
        
        fig.add_trace(go.Scatter(
            x=df.index, y=df['BB_Upper'],
            line=dict(color='orange', width=1, dash='dash'),
            name='Bollinger Upper'
        ), row=row, col=1)
        
        fig.add_trace(go.Scatter(
            x=df.index, y=df['BB_Lower'],
            line=dict(color='orange', width=1, dash='dash'),
            fill='tonexty',
            fillcolor='rgba(255,165,0,0.1)',
            name='Bollinger Lower'
        ), row=row, col=1)
    
    # EMA 20
    if show_ema and len(df) > 20:
        df['EMA20'] = df['Close'].ewm(span=20).mean()
        fig.add_trace(go.Scatter(
            x=df.index, y=df['EMA20'],
            line=dict(color='blue', width=2),
            name='EMA 20'
        ), row=row, col=1)
    
    # MACD
    if show_macd and 'MACD' in df.columns:
        # MACD line
        fig.add_trace(go.Scatter(
            x=df.index, y=df['MACD'],
            line=dict(color='blue', width=2),
            name='MACD'
        ), row=2, col=1)
        
        # Signal line
        fig.add_trace(go.Scatter(
            x=df.index, y=df['MACD_signal'],
            line=dict(color='red', width=1.5),
            name='Signal'
        ), row=2, col=1)
        
        # Histogramme
        colors_histogram = ['green' if x >= 0 else 'red' for x in df['MACD_histogram']]
        fig.add_trace(go.Bar(
            x=df.index, y=df['MACD_histogram'],
            marker_color=colors_histogram,
            name='Histogram',
            opacity=0.6
        ), row=2, col=1)
        
        # Ligne zÃ©ro
        fig.add_hline(y=0, line_dash="dot", line_color="gray", row=2, col=1)
    
    fig.update_layout(
        height=700,
        template='plotly_white',
        xaxis_rangeslider_visible=False,
        showlegend=True,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
    )
    
    if show_macd:
        fig.update_yaxes(title_text="Prix", row=1, col=1)
        fig.update_yaxes(title_text="MACD", row=2, col=1)
    else:
        fig.update_yaxes(title_text="Prix", row=1, col=1)
    
    return fig

def create_linebreak_chart(df, bricks, title):
    """Graphique LineBreak avec dates"""
    if not bricks or len(bricks) < 2:
        return None
    
    # Prendre les 8-10 derniÃ¨res briques (comme Boursorama)
    display_bricks = bricks[-10:] if len(bricks) > 10 else bricks
    
    fig = go.Figure()
    
    # RÃ©cupÃ©rer les dates correspondantes aux briques
    dates = [df.index[brick['index']] for brick in display_bricks]
    
    for i, (brick, date) in enumerate(zip(display_bricks, dates)):
        color = '#00CC00' if brick['type'] == 'green' else '#FF0000'
        border_color = '#009900' if brick['type'] == 'green' else '#CC0000'
        
        # Rectangle de la brique
        low = min(brick['open'], brick['close'])
        high = max(brick['open'], brick['close'])
        
        fig.add_trace(go.Scatter(
            x=[i-0.4, i+0.4, i+0.4, i-0.4, i-0.4],
            y=[low, low, high, high, low],
            fill="toself",
            fillcolor=color,
            line=dict(color=border_color, width=2),
            mode='lines',
            showlegend=False,
            name=f"Brique {i+1}",
            hovertemplate=f"Date: {date.strftime('%d/%m/%Y')}<br>" +
                         f"Type: {brick['type']}<br>" +
                         f"Open: {brick['open']:.2f}<br>" +
                         f"Close: {brick['close']:.2f}<br>" +
                         f"<extra></extra>"
        ))
        
        # Ligne mÃ©diane (caractÃ©ristique Boursorama)
        fig.add_trace(go.Scatter(
            x=[i-0.4, i+0.4],
            y=[brick['open'], brick['open']],
            line=dict(color='white', width=1.5),
            mode='lines',
            showlegend=False,
            hoverinfo='skip'
        ))
    
    # Annotation pour les 2 derniÃ¨res briques (signal)
    if len(display_bricks) >= 2:
        last_two = display_bricks[-2:]
        if (last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green'):
            signal_text = "ðŸ”´ â†’ ðŸŸ¢ ROUGE â†’ VERT"
            signal_color = "#00CC00"
        elif (last_two[0]['type'] == 'green' and last_two[1]['type'] == 'red'):
            signal_text = "ðŸŸ¢ â†’ ðŸ”´ VERT â†’ ROUGE"
            signal_color = "#FF0000"
        else:
            signal_text = None
        
        if signal_text:
            fig.add_annotation(
                x=len(display_bricks)-1,
                y=display_bricks[-1]['close'] * 1.02,
                text=signal_text,
                showarrow=True,
                arrowhead=2,
                arrowcolor=signal_color,
                font=dict(size=14, color=signal_color, family="Arial Black"),
                bgcolor="#F8F9FA",
                bordercolor=signal_color
            )
    
    # Configurer l'axe des x avec les dates
    fig.update_layout(
        title=dict(text=f"<b>{title}</b>", x=0.5, font=dict(size=16)),
        height=500,
        template='plotly_white',
        xaxis=dict(
            tickmode='array',
            tickvals=list(range(len(dates))),
            ticktext=[date.strftime('%d/%m') for date in dates],
            title="Dates (derniÃ¨res briques Ã  droite)"
        ),
        yaxis=dict(title="Prix"),
        showlegend=False,
        plot_bgcolor='#F8F9FA'
    )
    
    return fig

# ---------------------------------------------------------------------
# LISTES DES INDICES Ã‰TENDUES
# ---------------------------------------------------------------------

# CAC40
CAC40 = [
    ("AIR.PA","Airbus"), ("AI.PA","Air Liquide"), ("ALO.PA","Alstom"), ("MT.AS","ArcelorMittal"),
    ("CS.PA","AXA"), ("BNP.PA","BNP Paribas"), ("CAP.PA","Capgemini"), ("CA.PA","Carrefour"),
    ("ACA.PA","CrÃ©dit Agricole"), ("BN.PA","Danone"), ("DSY.PA","Dassault SystÃ¨mes"),
    ("EL.PA","EssilorLuxottica"), ("RMS.PA","HermÃ¨s"), ("KER.PA","Kering"),
    ("LR.PA","Legrand"), ("MC.PA","LVMH"), ("ORA.PA","Orange"), ("RI.PA","Pernod Ricard"),
    ("PUB.PA","Publicis"), ("RNO.PA","Renault"), ("GLE.PA","SociÃ©tÃ© GÃ©nÃ©rale"),
    ("STLA.PA","Stellantis"), ("SU.PA","Schneider Electric"), ("HO.PA","Thales"),
    ("TTE.PA","TotalEnergies"), ("VIE.PA","Veolia"), ("VIV.PA","Vivendi"),
    ("STM.PA","STMicroelectronics"), ("SGO.PA","Saint-Gobain"), ("DG.PA","Vinci"),
]

# SBF 120 (CAC40 + 80 autres valeurs)
SBF120 = CAC40 + [
    ("AC.PA", "Accor"), ("AF.PA", "Air France-KLM"), ("ATO.PA", "Atos"), 
    ("EN.PA", "Bouygues"), ("BVI.PA", "Bureau Veritas"), ("CO.PA", "Casino Guichard"),
    ("CNP.PA", "CNP Assurances"), ("EDEN.PA", "Edenred"), ("EDF.PA", "EDF"),
    ("EI.PA", "EssilorLuxottica"), ("ERF.PA", "Eurofins Scientific"), ("FR.PA", "Valeo"),
    ("FGR.PA", "Eiffage"), ("ICAD.PA", "Icade"), ("ITP.PA", "Interparfums"),
    ("LI.PA", "Klepierre"), ("OR.PA", "L'OrÃ©al"), ("MMB.PA", "LagardÃ¨re"),
    ("LG.PA", "LafargeHolcim"), ("MB.PA", "Michelin"), ("NEX.PA", "Nexans"),
    ("NK.PA", "Imerys"), ("UG.PA", "Peugeot"), ("SAF.PA", "Safran"),
    ("SAN.PA", "Sanofi"), ("SK.PA", "SEB"), ("SOI.PA", "Soitec"),
    ("TEP.PA", "Teleperformance"), ("TFI.PA", "TF1"), ("VK.PA", "Vallourec"),
    ("MF.PA", "Wendel"), ("XR.PA", "Rexel")
]

# Dow Jones (30 grandes entreprises amÃ©ricaines)
DOW_JONES = [
    ("AAPL", "Apple Inc."), ("MSFT", "Microsoft Corp."), ("AMZN", "Amazon.com Inc."),
    ("GOOGL", "Alphabet Inc."), ("META", "Meta Platforms Inc."), ("TSLA", "Tesla Inc."),
    ("BRK-B", "Berkshire Hathaway"), ("JNJ", "Johnson & Johnson"), ("V", "Visa Inc."),
    ("JPM", "JPMorgan Chase & Co."), ("WMT", "Walmart Inc."), ("PG", "Procter & Gamble"),
    ("UNH", "UnitedHealth Group"), ("DIS", "Walt Disney Co."), ("NVDA", "NVIDIA Corp."),
    ("HD", "Home Depot Inc."), ("PYPL", "PayPal Holdings"), ("NFLX", "Netflix Inc."),
    ("ADBE", "Adobe Inc."), ("CRM", "Salesforce.com"), ("INTC", "Intel Corp."),
    ("CSCO", "Cisco Systems"), ("PFE", "Pfizer Inc."), ("ABT", "Abbott Laboratories"),
    ("T", "AT&T Inc."), ("VZ", "Verizon Communications"), ("KO", "Coca-Cola Co."),
    ("PEP", "PepsiCo Inc."), ("XOM", "Exxon Mobil Corp."), ("CVX", "Chevron Corp.")
]

# NASDAQ 100 (100 principales entreprises tech)
NASDAQ100 = [
    ("AAPL", "Apple Inc."), ("MSFT", "Microsoft Corp."), ("AMZN", "Amazon.com Inc."),
    ("GOOGL", "Alphabet Inc."), ("GOOG", "Alphabet Inc. C"), ("META", "Meta Platforms Inc."),
    ("TSLA", "Tesla Inc."), ("NVDA", "NVIDIA Corp."), ("AVGO", "Broadcom Inc."),
    ("PEP", "PepsiCo Inc."), ("COST", "Costco Wholesale"), ("ADBE", "Adobe Inc."),
    ("CSCO", "Cisco Systems"), ("CMCSA", "Comcast Corp."), ("NFLX", "Netflix Inc."),
    ("INTC", "Intel Corp."), ("AMD", "Advanced Micro Devices"), ("TMUS", "T-Mobile US"),
    ("TXN", "Texas Instruments"), ("QCOM", "Qualcomm Inc."), ("HON", "Honeywell International"),
    ("AMGN", "Amgen Inc."), ("SBUX", "Starbucks Corp."), ("INTU", "Intuit Inc."),
    ("AMAT", "Applied Materials"), ("ISRG", "Intuitive Surgical"), ("MDLZ", "Mondelez International"),
    ("GILD", "Gilead Sciences"), ("ADP", "Automatic Data Processing"), ("VRTX", "Vertex Pharmaceuticals"),
    ("REGN", "Regeneron Pharmaceuticals"), ("ADI", "Analog Devices"), ("BKNG", "Booking Holdings"),
    ("PYPL", "PayPal Holdings"), ("MRNA", "Moderna Inc."), ("LRCX", "Lam Research"),
    ("CSX", "CSX Corp."), ("KLAC", "KLA Corp."), ("SNPS", "Synopsys Inc."),
    ("CDNS", "Cadence Design Systems"), ("ASML", "ASML Holding"), ("CHTR", "Charter Communications"),
    ("MAR", "Marriott International"), ("MU", "Micron Technology"), ("CTAS", "Cintas Corp."),
    ("ORLY", "O'Reilly Automotive"), ("ABNB", "Airbnb Inc."), ("MELI", "MercadoLibre Inc."),
    ("MNST", "Monster Beverage"), ("PANW", "Palo Alto Networks"), ("KDP", "Keurig Dr Pepper"),
    ("DXCM", "Dexcom Inc."), ("KHC", "Kraft Heinz Co."), ("AZN", "AstraZeneca PLC"),
    ("AEP", "American Electric Power"), ("ADSK", "Autodesk Inc."), ("BIIB", "Biogen Inc."),
    ("IDXX", "IDEXX Laboratories"), ("EXC", "Exelon Corp."), ("MCHP", "Microchip Technology"),
    ("XEL", "Xcel Energy Inc."), ("LULU", "Lululemon Athletica"), ("CTSH", "Cognizant Technology Solutions"),
    ("WDAY", "Workday Inc."), ("ODFL", "Old Dominion Freight Line"), ("ROST", "Ross Stores Inc."),
    ("DLTR", "Dollar Tree Inc."), ("EA", "Electronic Arts"), ("VRSK", "Verisk Analytics"),
    ("CPRT", "Copart Inc."), ("CSGP", "CoStar Group"), ("FAST", "Fastenal Co."),
    ("CRWD", "CrowdStrike Holdings"), ("BKR", "Baker Hughes Co."), ("PCAR", "PACCAR Inc."),
    ("ANSS", "ANSYS Inc."), ("CEG", "Constellation Energy"), ("DDOG", "Datadog Inc."),
    ("TEAM", "Atlassian Corp."), ("FANG", "Diamondback Energy"), ("ZS", "Zscaler Inc."),
    ("SIRI", "Sirius XM Holdings"), ("ALGN", "Align Technology"), ("JD", "JD.com Inc."),
    ("EBAY", "eBay Inc."), ("VOD", "Vodafone Group"), ("WBD", "Warner Bros Discovery"),
    ("RIVN", "Rivian Automotive"), ("ZS", "Zscaler Inc."), ("LCID", "Lucid Group Inc.")
]

# S&P 500 (Top 100 entreprises)
SP500 = [
    ("AAPL", "Apple Inc."), ("MSFT", "Microsoft Corp."), ("AMZN", "Amazon.com Inc."),
    ("GOOGL", "Alphabet Inc."), ("GOOG", "Alphabet Inc. C"), ("META", "Meta Platforms Inc."),
    ("TSLA", "Tesla Inc."), ("NVDA", "NVIDIA Corp."), ("BRK-B", "Berkshire Hathaway"),
    ("JNJ", "Johnson & Johnson"), ("V", "Visa Inc."), ("JPM", "JPMorgan Chase & Co."),
    ("WMT", "Walmart Inc."), ("PG", "Procter & Gamble"), ("UNH", "UnitedHealth Group"),
    ("DIS", "Walt Disney Co."), ("HD", "Home Depot Inc."), ("PYPL", "PayPal Holdings"),
    ("NFLX", "Netflix Inc."), ("ADBE", "Adobe Inc."), ("CRM", "Salesforce.com"),
    ("INTC", "Intel Corp."), ("CSCO", "Cisco Systems"), ("PFE", "Pfizer Inc."),
    ("ABT", "Abbott Laboratories"), ("T", "AT&T Inc."), ("VZ", "Verizon Communications"),
    ("KO", "Coca-Cola Co."), ("PEP", "PepsiCo Inc."), ("XOM", "Exxon Mobil Corp."),
    ("CVX", "Chevron Corp."), ("MRK", "Merck & Co."), ("LLY", "Eli Lilly & Co."),
    ("AVGO", "Broadcom Inc."), ("TMO", "Thermo Fisher Scientific"), ("ABBV", "AbbVie Inc."),
    ("ACN", "Accenture PLC"), ("DHR", "Danaher Corp."), ("WFC", "Wells Fargo & Co."),
    ("NKE", "Nike Inc."), ("PM", "Philip Morris International"), ("TXN", "Texas Instruments"),
    ("COST", "Costco Wholesale"), ("UPS", "United Parcel Service"), ("NEE", "NextEra Energy"),
    ("RTX", "Raytheon Technologies"), ("HON", "Honeywell International"), ("IBM", "International Business Machines"),
    ("AMD", "Advanced Micro Devices"), ("SBUX", "Starbucks Corp."), ("AMGN", "Amgen Inc."),
    ("MDT", "Medtronic PLC"), ("SPGI", "S&P Global Inc."), ("LOW", "Lowe's Companies"),
    ("CAT", "Caterpillar Inc."), ("GS", "Goldman Sachs Group"), ("AXP", "American Express Co."),
    ("PLD", "Prologis Inc."), ("DE", "Deere & Co."), ("BA", "Boeing Co."),
    ("UNP", "Union Pacific Corp."), ("NOW", "ServiceNow Inc."), ("TGT", "Target Corp."),
    ("ISRG", "Intuitive Surgical"), ("SYK", "Stryker Corp."), ("LMT", "Lockheed Martin Corp."),
    ("INTU", "Intuit Inc."), ("ADI", "Analog Devices"), ("MDLZ", "Mondelez International"),
    ("CB", "Chubb Ltd."), ("C", "Citigroup Inc."), ("BLK", "BlackRock Inc."),
    ("AMT", "American Tower Corp."), ("MO", "Altria Group Inc."), ("SCHW", "Charles Schwab Corp."),
    ("CI", "Cigna Corp."), ("ZTS", "Zoetis Inc."), ("MMC", "Marsh & McLennan Companies"),
    ("PNC", "PNC Financial Services"), ("DUK", "Duke Energy Corp."), ("SO", "Southern Co."),
    ("BDX", "Becton Dickinson & Co."), ("BSX", "Boston Scientific Corp."), ("CL", "Colgate-Palmolive Co."),
    ("APD", "Air Products & Chemicals"), ("NOC", "Northrop Grumman Corp."), ("AON", "Aon PLC"),
    ("MCO", "Moody's Corp."), ("EOG", "EOG Resources"), ("CME", "CME Group Inc."),
    ("ICE", "Intercontinental Exchange"), ("SHW", "Sherwin-Williams Co."), ("WM", "Waste Management Inc."),
    ("GD", "General Dynamics Corp."), ("FIS", "Fidelity National Information Services"), ("ITW", "Illinois Tool Works")
]

# Actions europÃ©ennes supplÃ©mentaires
EUROPE_EXTENDED = [
    ("ASML.AS", "ASML Holding NV"), ("SAF.PA", "Safran SA"), ("SAN.PA", "Sanofi SA"),
    ("OR.PA", "L'Oreal SA"), ("AI.PA", "Air Liquide SA"), ("SU.PA", "Schneider Electric SE"),
    ("AIR.PA", "Airbus SE"), ("MC.PA", "LVMH Moet Hennessy"), ("ADS.DE", "Adidas AG"),
    ("ALV.DE", "Allianz SE"), ("BAS.DE", "BASF SE"), ("BAYN.DE", "Bayer AG"),
    ("BMW.DE", "BMW AG"), ("CON.DE", "Continental AG"), ("DAI.DE", "Daimler Truck Holding"),
    ("DBK.DE", "Deutsche Bank AG"), ("DB1.DE", "Deutsche Boerse AG"), ("DPW.DE", "Deutsche Post AG"),
    ("DTE.DE", "Deutsche Telekom AG"), ("EOAN.DE", "E.ON SE"), ("FME.DE", "Fresenius Medical Care AG"),
    ("FRE.DE", "Fresenius SE & Co KGaA"), ("HEI.DE", "HeidelbergCement AG"), ("HEN3.DE", "Henkel AG & Co KGaA"),
    ("IFX.DE", "Infineon Technologies AG"), ("LIN.DE", "Linde PLC"), ("MRK.DE", "Merck KGaA"),
    ("MUV2.DE", "Munich Re AG"), ("RWE.DE", "RWE AG"), ("SAP.DE", "SAP SE"),
    ("SIE.DE", "Siemens AG"), ("VOW3.DE", "Volkswagen AG"), ("ENEL.MI", "Enel SpA"),
    ("ENI.MI", "Eni SpA"), ("ISP.MI", "Intesa Sanpaolo SpA"), ("STM.MI", "STMicroelectronics NV"),
    ("TIT.MI", "Telecom Italia SpA"), ("UBI.MI", "UniCredit SpA"), ("NOVOb.CO", "Novo Nordisk A/S"),
    ("VWS.CO", "Vestas Wind Systems A/S"), ("AZN.L", "AstraZeneca PLC"), ("GSK.L", "GlaxoSmithKline PLC"),
    ("HSBA.L", "HSBC Holdings PLC"), ("BP.L", "BP PLC"), ("RDSA.L", "Royal Dutch Shell PLC"),
    ("ULVR.L", "Unilever PLC"), ("DGE.L", "Diageo PLC"), ("RIO.L", "Rio Tinto PLC"),
    ("BARC.L", "Barclays PLC"), ("LLOY.L", "Lloyds Banking Group PLC"), ("NG.L", "National Grid PLC"),
    ("TSCO.L", "Tesco PLC"), ("VOD.L", "Vodafone Group PLC"), ("BATS.L", "British American Tobacco PLC")
]

# Cryptomonnaies et ETFs
CRYPTO_ETFS = [
    ("BTC-USD", "Bitcoin USD"), ("ETH-USD", "Ethereum USD"), ("ADA-USD", "Cardano USD"),
    ("DOT-USD", "Polkadot USD"), ("LTC-USD", "Litecoin USD"), ("XRP-USD", "Ripple USD"),
    ("BCH-USD", "Bitcoin Cash USD"), ("LINK-USD", "Chainlink USD"), ("UNI-USD", "Uniswap USD"),
    ("DOGE-USD", "Dogecoin USD"), ("SOL-USD", "Solana USD"), ("AVAX-USD", "Avalanche USD"),
    ("MATIC-USD", "Polygon USD"), ("ATOM-USD", "Cosmos USD"), ("ALGO-USD", "Algorand USD"),
    ("SPY", "SPDR S&P 500 ETF"), ("QQQ", "Invesco QQQ Trust"), ("IWM", "iShares Russell 2000 ETF"),
    ("EEM", "iShares MSCI Emerging Markets ETF"), ("VGK", "Vanguard FTSE Europe ETF"),
    ("VOO", "Vanguard S&P 500 ETF"), ("IVV", "iShares Core S&P 500 ETF"), ("DIA", "SPDR Dow Jones Industrial Average ETF")
]

# Combiner toutes les actions
ALL_STOCKS = CAC40 + SBF120 + DOW_JONES + NASDAQ100 + SP500 + EUROPE_EXTENDED + CRYPTO_ETFS
# Supprimer les doublons
ALL_STOCKS = list(dict.fromkeys(ALL_STOCKS))

# Dictionnaire des indices
INDICES = {
    "CAC40": CAC40,
    "SBF120": SBF120, 
    "Dow Jones": DOW_JONES,
    "NASDAQ100": NASDAQ100,
    "S&P500": SP500,
    "Europe Ã©tendu": EUROPE_EXTENDED,
    "Crypto & ETFs": CRYPTO_ETFS,
    "TOUTES LES ACTIONS": ALL_STOCKS
}

# ---------------------------------------------------------------------
# SYSTÃˆME DE FAVORIS AMÃ‰LIORÃ‰
# ---------------------------------------------------------------------
def init_favoris():
    """Initialise la liste des favoris dans le session state"""
    if 'favoris' not in st.session_state:
        st.session_state.favoris = []
    if 'last_analyzed' not in st.session_state:
        st.session_state.last_analyzed = None

def toggle_favori(symbol, name):
    """Ajoute ou retire un favori"""
    init_favoris()
    favori_item = (symbol, name)
    
    if favori_item in st.session_state.favoris:
        st.session_state.favoris.remove(favori_item)
        st.success(f"âŒ {name} retirÃ© des favoris")
    else:
        st.session_state.favoris.append(favori_item)
        st.success(f"â­ {name} ajoutÃ© aux favoris")
    
    # Forcer le rerun pour mettre Ã  jour l'interface
    st.rerun()

# ---------------------------------------------------------------------
# SCANNER TRADING (TOUS LES INDICES)
# ---------------------------------------------------------------------
def run_scanner():
    st.markdown("### ðŸ” Scanner Trading")
    
    # Initialisation du session state
    if 'scan_results' not in st.session_state:
        st.session_state.scan_results = None
    if 'scan_done' not in st.session_state:
        st.session_state.scan_done = False
    if 'selected_index' not in st.session_state:
        st.session_state.selected_index = "CAC40"
    
    st.info("""
    **ðŸŽ¯ RÃ¨gle LineBreak :** DÃ©tection des actions oÃ¹ les **2 derniÃ¨res briques LineBreak alternent** 
    - ðŸ”´ â†’ ðŸŸ¢ **ROUGE puis VERT** = Tendance haussiÃ¨re
    - ðŸŸ¢ â†’ ðŸ”´ **VERT puis ROUGE** = Tendance baissiÃ¨re
    - **PÃ©riode :** 3 mois â€¢ **Reversal :** 2 briques
    """)
    
    # Options indicateurs seulement
    st.sidebar.markdown("### ðŸ“Š Options indicateurs")
    show_bollinger = st.sidebar.checkbox("Bandes de Bollinger", value=True, key="boll_scanner")
    show_ema = st.sidebar.checkbox("EMA 20 (courbe de tendance)", value=True, key="ema_scanner")
    show_macd = st.sidebar.checkbox("MACD", value=True, key="macd_scanner")
    auto_display = st.sidebar.checkbox("Afficher graphiques auto", value=False, key="auto_scanner")
    
    # SÃ©lection de l'indice dans la sidebar
    st.sidebar.markdown("### ðŸ“ˆ Indice Ã  scanner")
    selected_index = st.sidebar.selectbox(
        "Choisir l'indice:",
        list(INDICES.keys()),
        key="index_selector_scanner"
    )
    
    # Bouton de scan dans la sidebar
    if st.sidebar.button("ðŸš€ Lancer le scan", key="scan_trading_main") or not st.session_state.scan_done:
        st.session_state.selected_index = selected_index
        perform_scan(selected_index)
    
    # Afficher les rÃ©sultats si disponibles
    if st.session_state.scan_results is not None:
        display_scan_results(st.session_state.scan_results, show_bollinger, show_ema, show_macd, auto_display, selected_index)

def perform_scan(selected_index):
    """Effectue le scan et stocke les rÃ©sultats"""
    stocks_list = INDICES[selected_index]
    hits = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, (symbol, name) in enumerate(stocks_list):
        status_text.text(f"ðŸ” Analyse de {name}...")
        progress_bar.progress((i + 1) / len(stocks_list))
        
        try:
            # PÃ©riode FIXE 3mo pour LineBreak
            df = get_clean_data(symbol, "3mo")
            if df is not None and len(df) > 20:
                signal_detected, bricks = detect_boursorama_signal(df)
                if signal_detected:
                    hits.append((symbol, name, df, bricks))
        except Exception as e:
            continue
    
    progress_bar.empty()
    status_text.empty()
    
    # Stocker les rÃ©sultats dans session state
    st.session_state.scan_results = hits
    st.session_state.scan_done = True

def display_scan_results(hits, show_bollinger, show_ema, show_macd, auto_display, selected_index):
    """Affiche les rÃ©sultats du scan avec interactivitÃ©"""
    if hits:
        st.success(f"**{len(hits)} signal(s) dÃ©tectÃ©(s) dans le {selected_index}**")
        
        for symbol, name, df, bricks in hits:
            # DÃ©terminer le type de signal
            last_two = bricks[-2:]
            if last_two and last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
                signal_type = "ðŸ”´ â†’ ðŸŸ¢ ROUGE â†’ VERT"
                signal_emoji = "ðŸ”´ðŸŸ¢"
                signal_direction = "HAUSSE"
            else:
                signal_type = "ðŸŸ¢ â†’ ðŸ”´ VERT â†’ ROUGE" 
                signal_emoji = "ðŸŸ¢ðŸ”´"
                signal_direction = "BAISSE"
            
            with st.expander(f"{signal_emoji} {name} ({symbol}) - {signal_type} - {signal_direction}", expanded=auto_display):
                
                # Bouton favori
                col_btn1, col_btn2 = st.columns([1, 4])
                with col_btn1:
                    is_favori = (symbol, name) in st.session_state.get('favoris', [])
                    favori_text = "âŒ Retirer des favoris" if is_favori else "â­ Ajouter aux favoris"
                    if st.button(favori_text, key=f"fav_{symbol}_{name}"):
                        toggle_favori(symbol, name)
                
                # MÃ©triques avec vÃ©rification de l'actualisation
                current_price = df['Close'].iloc[-1]
                prev_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
                change = current_price - prev_price
                change_pct = (change / prev_price) * 100
                
                # VÃ©rifier si les donnÃ©es sont Ã  jour
                last_data_date = df.index[-1].date()
                today = datetime.now().date()
                is_up_to_date = (today - last_data_date).days <= 1
                
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%")
                col2.metric("Variation", f"{change:+.2f}")
                
                # Afficher la date avec un indicateur d'actualisation
                date_display = df.index[-1].strftime("%d/%m/%Y")
                if not is_up_to_date:
                    date_display += " âš ï¸"
                col3.metric("DerniÃ¨re MAJ", date_display)
                
                col4.metric("Signal", signal_direction)
                
                if not is_up_to_date:
                    st.warning(f"âš ï¸ Les donnÃ©es de {name} ne sont pas Ã  jour. DerniÃ¨re date: {df.index[-1].strftime('%d/%m/%Y')}")
                
                # Graphiques avec option de pÃ©riode pour le graphique complet seulement
                st.markdown("#### ðŸ“Š Graphiques")
                
                # SÃ©lecteur de pÃ©riode pour le graphique complet avec interactivitÃ©
                chart_period = st.selectbox(
                    f"PÃ©riode pour {name}",
                    ["1mo", "3mo", "6mo", "1y"],
                    index=1,
                    key=f"chart_period_{symbol}_{name}"
                )
                
                # RÃ©cupÃ©rer donnÃ©es pour la pÃ©riode choisie
                df_chart = get_clean_data(symbol, chart_period)
                
                tab1, tab2 = st.tabs(["ðŸ“ˆ Graphique Complet", "ðŸ§± LineBreak (3 mois)"])
                
                with tab1:
                    if df_chart is not None:
                        st.plotly_chart(
                            create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                            use_container_width=True,
                            key=f"chart_{symbol}_{name}_{chart_period}"
                        )
                    else:
                        st.error("DonnÃ©es non disponibles pour cette pÃ©riode")
                
                with tab2:
                    lb_chart = create_linebreak_chart(df, bricks, f"{name} - LineBreak (3 mois)")
                    if lb_chart:
                        st.plotly_chart(lb_chart, use_container_width=True, key=f"lb_{symbol}_{name}")
                    else:
                        st.warning("DonnÃ©es LineBreak insuffisantes")
    
    else:
        st.info(f"ðŸ¤– Aucune alternance dÃ©tectÃ©e dans le {selected_index} pour le moment.")
        st.caption("ðŸ’¡ _Les signaux LineBreak sont rares - c'est normal d'en avoir peu_")

# ---------------------------------------------------------------------
# SCANNER FAVORIS COMPLET AVEC SCAN
# ---------------------------------------------------------------------
def run_favoris():
    st.markdown("### â­ Scanner Favoris")
    
    init_favoris()
    
    if not st.session_state.favoris:
        st.info("ðŸŒŸ Aucun favori ajoutÃ©. Utilisez le scanner Trading pour ajouter des actions Ã  vos favoris.")
        return
    
    st.info(f"**ðŸ“Š {len(st.session_state.favoris)} action(s) dans les favoris**")
    
    # Options indicateurs
    st.sidebar.markdown("### ðŸ“Š Options indicateurs")
    show_bollinger = st.sidebar.checkbox("Bandes de Bollinger", value=True, key="boll_fav")
    show_ema = st.sidebar.checkbox("EMA 20 (courbe de tendance)", value=True, key="ema_fav")
    show_macd = st.sidebar.checkbox("MACD", value=True, key="macd_fav")
    auto_display_fav = st.sidebar.checkbox("Afficher graphiques auto", value=False, key="auto_fav")
    
    # BOUTON DE SCAN DANS LA SIDEBAR POUR LES FAVORIS
    if st.sidebar.button("ðŸš€ Scanner les favoris", key="scan_favoris_main"):
        st.session_state.favoris_mode = "scan"
        st.rerun()
    
    # CHOIX DU MODE : Scan des signaux ou Tous les favoris
    mode_favoris = st.radio(
        "Mode d'affichage:",
        ["ðŸ” Scanner les favoris", "â­ Tous mes favoris"],
        horizontal=True,
        key="mode_favoris_main"
    )
    
    if mode_favoris == "ðŸ” Scanner les favoris":
        # Scanner des favoris avec dÃ©tection de signaux
        scan_favoris(show_bollinger, show_ema, show_macd, auto_display_fav)
    else:
        # Affichage de tous les favoris
        display_all_favoris(show_bollinger, show_ema, show_macd, auto_display_fav)

def scan_favoris(show_bollinger, show_ema, show_macd, auto_display):
    """Scan des favoris pour dÃ©tecter les signaux LineBreak"""
    if not st.session_state.favoris:
        return
    
    # Scanner les favoris pour trouver les signaux
    hits = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, (symbol, name) in enumerate(st.session_state.favoris):
        status_text.text(f"ðŸ” Scan de {name}...")
        progress_bar.progress((i + 1) / len(st.session_state.favoris))
        
        try:
            # PÃ©riode FIXE 3mo pour LineBreak
            df = get_clean_data(symbol, "3mo")
            if df is not None and len(df) > 20:
                signal_detected, bricks = detect_boursorama_signal(df)
                if signal_detected:
                    hits.append((symbol, name, df, bricks))
        except Exception as e:
            continue
    
    progress_bar.empty()
    status_text.empty()
    
    if hits:
        st.success(f"**ðŸŽ¯ {len(hits)} signal(s) dÃ©tectÃ©(s) parmi vos favoris**")
        
        for symbol, name, df, bricks in hits:
            # DÃ©terminer le type de signal
            last_two = bricks[-2:]
            if last_two and last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
                signal_type = "ðŸ”´ â†’ ðŸŸ¢ ROUGE â†’ VERT"
                signal_emoji = "ðŸ”´ðŸŸ¢"
                signal_direction = "HAUSSE"
            else:
                signal_type = "ðŸŸ¢ â†’ ðŸ”´ VERT â†’ ROUGE" 
                signal_emoji = "ðŸŸ¢ðŸ”´"
                signal_direction = "BAISSE"
            
            with st.expander(f"{signal_emoji} {name} ({symbol}) - {signal_type} - {signal_direction}", expanded=auto_display):
                
                # Bouton retirer favori
                if st.button("âŒ Retirer des favoris", key=f"remove_fav_{symbol}_{name}"):
                    toggle_favori(symbol, name)
                
                # MÃ©triques avec vÃ©rification de l'actualisation
                current_price = df['Close'].iloc[-1]
                prev_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
                change = current_price - prev_price
                change_pct = (change / prev_price) * 100
                
                # VÃ©rifier si les donnÃ©es sont Ã  jour
                last_data_date = df.index[-1].date()
                today = datetime.now().date()
                is_up_to_date = (today - last_data_date).days <= 1
                
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%")
                col2.metric("Variation", f"{change:+.2f}")
                
                # Afficher la date avec un indicateur d'actualisation
                date_display = df.index[-1].strftime("%d/%m/%Y")
                if not is_up_to_date:
                    date_display += " âš ï¸"
                col3.metric("DerniÃ¨re MAJ", date_display)
                
                col4.metric("Signal", signal_direction)
                
                if not is_up_to_date:
                    st.warning(f"âš ï¸ Les donnÃ©es de {name} ne sont pas Ã  jour. DerniÃ¨re date: {df.index[-1].strftime('%d/%m/%Y')}")
                
                # Graphiques avec option de pÃ©riode
                st.markdown("#### ðŸ“Š Graphiques")
                
                # SÃ©lecteur de pÃ©riode pour le graphique complet
                chart_period = st.selectbox(
                    f"PÃ©riode pour {name}",
                    ["1mo", "3mo", "6mo", "1y"],
                    index=1,
                    key=f"scan_period_{symbol}_{name}"
                )
                
                # RÃ©cupÃ©rer donnÃ©es pour la pÃ©riode choisie
                df_chart = get_clean_data(symbol, chart_period)
                
                tab1, tab2 = st.tabs(["ðŸ“ˆ Graphique Complet", "ðŸ§± LineBreak (3 mois)"])
                
                with tab1:
                    if df_chart is not None:
                        st.plotly_chart(
                            create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                            use_container_width=True,
                            key=f"scan_chart_{symbol}_{name}_{chart_period}"
                        )
                    else:
                        st.error("DonnÃ©es non disponibles pour cette pÃ©riode")
                
                with tab2:
                    if bricks:
                        lb_chart = create_linebreak_chart(df, bricks, f"{name} - LineBreak (3 mois)")
                        if lb_chart:
                            st.plotly_chart(lb_chart, use_container_width=True, key=f"scan_lb_{symbol}_{name}")
                        else:
                            st.warning("DonnÃ©es LineBreak insuffisantes")
                    else:
                        st.info("Aucune brique LineBreak disponible")
    
    else:
        st.info("ðŸ¤– Aucun signal dÃ©tectÃ© parmi vos favoris pour le moment.")
        st.caption("ðŸ’¡ _Les signaux LineBreak sont rares - surveillez rÃ©guliÃ¨rement vos favoris_")

def display_all_favoris(show_bollinger, show_ema, show_macd, auto_display):
    """Affiche tous les favoris avec leurs graphiques complets"""
    if not st.session_state.favoris:
        return
    
    # Analyser tous les favoris
    favoris_data = []
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for i, (symbol, name) in enumerate(st.session_state.favoris):
        status_text.text(f"ðŸ“Š Chargement de {name}...")
        progress_bar.progress((i + 1) / len(st.session_state.favoris))
        
        try:
            # PÃ©riode FIXE 3mo pour LineBreak
            df = get_clean_data(symbol, "3mo")
            if df is not None and len(df) > 20:
                signal_detected, bricks = detect_boursorama_signal(df)
                favoris_data.append((symbol, name, df, bricks, signal_detected))
        except Exception as e:
            continue
    
    progress_bar.empty()
    status_text.empty()
    
    # Afficher tous les favoris
    for symbol, name, df, bricks, signal_detected in favoris_data:
        # DÃ©terminer le type de signal
        if signal_detected and bricks and len(bricks) >= 2:
            last_two = bricks[-2:]
            if last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
                signal_type = "ðŸ”´ â†’ ðŸŸ¢ ROUGE â†’ VERT"
                signal_emoji = "ðŸ”´ðŸŸ¢"
                signal_direction = "HAUSSE"
            else:
                signal_type = "ðŸŸ¢ â†’ ðŸ”´ VERT â†’ ROUGE" 
                signal_emoji = "ðŸŸ¢ðŸ”´"
                signal_direction = "BAISSE"
        else:
            signal_type = "Aucun signal"
            signal_emoji = "âšª"
            signal_direction = "NEUTRE"
        
        with st.expander(f"{signal_emoji} {name} ({symbol}) - {signal_type} - {signal_direction}", expanded=auto_display):
            
            # Bouton retirer favori
            if st.button("âŒ Retirer des favoris", key=f"remove_fav_all_{symbol}_{name}"):
                toggle_favori(symbol, name)
            
            # MÃ©triques avec vÃ©rification de l'actualisation
            current_price = df['Close'].iloc[-1]
            prev_price = df['Close'].iloc[-2] if len(df) > 1 else current_price
            change = current_price - prev_price
            change_pct = (change / prev_price) * 100
            
            # VÃ©rifier si les donnÃ©es sont Ã  jour
            last_data_date = df.index[-1].date()
            today = datetime.now().date()
            is_up_to_date = (today - last_data_date).days <= 1
            
            col1, col2, col3, col4 = st.columns(4)
            col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%")
            col2.metric("Variation", f"{change:+.2f}")
            
            # Afficher la date avec un indicateur d'actualisation
            date_display = df.index[-1].strftime("%d/%m/%Y")
            if not is_up_to_date:
                date_display += " âš ï¸"
            col3.metric("DerniÃ¨re MAJ", date_display)
            
            col4.metric("Signal", signal_direction)
            
            if not is_up_to_date:
                st.warning(f"âš ï¸ Les donnÃ©es de {name} ne sont pas Ã  jour. DerniÃ¨re date: {df.index[-1].strftime('%d/%m/%Y')}")
            
            # Graphiques avec option de pÃ©riode
            st.markdown("#### ðŸ“Š Graphiques")
            
            # SÃ©lecteur de pÃ©riode pour le graphique complet
            chart_period = st.selectbox(
                f"PÃ©riode pour {name}",
                ["1mo", "3mo", "6mo", "1y"],
                index=1,
                key=f"fav_period_{symbol}_{name}"
            )
            
            # RÃ©cupÃ©rer donnÃ©es pour la pÃ©riode choisie
            df_chart = get_clean_data(symbol, chart_period)
            
            tab1, tab2 = st.tabs(["ðŸ“ˆ Graphique Complet", "ðŸ§± LineBreak (3 mois)"])
            
            with tab1:
                if df_chart is not None:
                    st.plotly_chart(
                        create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                        use_container_width=True,
                        key=f"fav_chart_{symbol}_{name}_{chart_period}"
                    )
                else:
                    st.error("DonnÃ©es non disponibles pour cette pÃ©riode")
            
            with tab2:
                if bricks:
                    lb_chart = create_linebreak_chart(df, bricks, f"{name} - LineBreak (3 mois)")
                    if lb_chart:
                        st.plotly_chart(lb_chart, use_container_width=True, key=f"fav_lb_{symbol}_{name}")
                    else:
                        st.warning("DonnÃ©es LineBreak insuffisantes")
                else:
                    st.info("Aucune brique LineBreak disponible")

# ---------------------------------------------------------------------
# ANALYSE INDIVIDUELLE AMÃ‰LIORÃ‰E (TOUTES LES ACTIONS)
# ---------------------------------------------------------------------
def run_individual_analysis():
    st.markdown("### ðŸ” Analyse Individuelle")
    
    # Mode de sÃ©lection : liste prÃ©dÃ©finie OU saisie libre
    selection_mode = st.radio(
        "Mode de sÃ©lection:",
        ["ðŸ“‹ Liste prÃ©dÃ©finie", "ðŸ” Recherche libre"],
        horizontal=True,
        key="selection_mode_main"
    )
    
    # Options indicateurs dans la sidebar - UNIQUEMENT ICI
    st.sidebar.markdown("### ðŸ“Š Options indicateurs")
    show_bollinger = st.sidebar.checkbox("Bandes de Bollinger", value=True, key="boll_indiv_unique")
    show_ema = st.sidebar.checkbox("EMA 20 (courbe de tendance)", value=True, key="ema_indiv_unique") 
    show_macd = st.sidebar.checkbox("MACD", value=True, key="macd_indiv_unique")
    
    # SÃ©lecteur de pÃ©riode pour l'analyse individuelle
    st.sidebar.markdown("### â° PÃ©riode graphique")
    chart_period = st.sidebar.selectbox(
        "PÃ©riode affichage",
        ["1mo", "3mo", "6mo", "1y"],
        index=1,
        key="period_indiv_unique"
    )
    
    if selection_mode == "ðŸ“‹ Liste prÃ©dÃ©finie":
        # Combiner toutes les actions de tous les indices
        all_stocks = []
        for index_name, stocks in INDICES.items():
            for symbol, name in stocks:
                all_stocks.append((symbol, name, index_name))
        
        # Stocker l'action sÃ©lectionnÃ©e dans le session state
        if 'selected_stock' not in st.session_state:
            st.session_state.selected_stock = f"{all_stocks[0][1]} ({all_stocks[0][0]}) - {all_stocks[0][2]}"
        
        selected_stock = st.selectbox(
            "Choisir une action:",
            [f"{name} ({symbol}) - {index_name}" for symbol, name, index_name in all_stocks],
            index=0,
            key="stock_selector_predefined"
        )
        
        # Extraire le symbole et le nom
        symbol = selected_stock.split("(")[1].split(")")[0]
        name = selected_stock.split("(")[0].strip()
        
    else:  # Mode recherche libre
        st.info("ðŸ’¡ **Recherche libre** : Choisissez parmi 500+ actions mondiales ou saisissez un symbole manuellement")
        
        # Utiliser TOUTES les actions pour la recherche libre
        all_stocks_free = ALL_STOCKS
        
        # Trier par nom pour faciliter la recherche
        all_stocks_free.sort(key=lambda x: x[1])
        
        # SÃ©lecteur avec recherche pour la recherche libre
        if 'selected_free_stock' not in st.session_state:
            st.session_state.selected_free_stock = f"{all_stocks_free[0][1]} ({all_stocks_free[0][0]})"
        
        selected_free_stock = st.selectbox(
            "Choisir une action:",
            [f"{name} ({symbol})" for symbol, name in all_stocks_free],
            index=0,
            key="free_stock_selector_search"
        )
        
        # Extraire le symbole et le nom
        symbol = selected_free_stock.split("(")[1].split(")")[0]
        name = selected_free_stock.split("(")[0].strip()
    
    # Stocker la derniÃ¨re action analysÃ©e
    st.session_state.last_analyzed = (symbol, name)
    
    # AFFICHAGE DE L'ANALYSE
    display_individual_analysis(symbol, name, chart_period, show_bollinger, show_ema, show_macd)

def display_individual_analysis(symbol, name, chart_period, show_bollinger, show_ema, show_macd):
    """Affiche l'analyse pour une action donnÃ©e (utilisÃ© par les deux modes)"""
    
    # DonnÃ©es pour LineBreak (3mo FIXE)
    df_lb = get_clean_data(symbol, "3mo")
    # DonnÃ©es pour graphique complet (pÃ©riode choisie)
    df_chart = get_clean_data(symbol, chart_period)
    
    if df_lb is None or df_lb.empty:
        st.error(f"âŒ DonnÃ©es non disponibles pour {symbol}")
        st.info("ðŸ’¡ VÃ©rifiez que le symbole est correct et existe sur Yahoo Finance")
        return
    
    signal_detected, bricks = detect_boursorama_signal(df_lb)
    
    # Bouton favori - AMÃ‰LIORÃ‰
    is_favori = (symbol, name) in st.session_state.get('favoris', [])
    favori_text = "âŒ Retirer des favoris" if is_favori else "â­ Ajouter aux favoris"
    fav_col1, fav_col2 = st.columns([1, 5])
    with fav_col1:
        if st.button(favori_text, key=f"fav_indiv_{symbol}_{name}", type="primary" if not is_favori else "secondary"):
            toggle_favori(symbol, name)
    
    # MÃ©triques avec vÃ©rification de l'actualisation
    current_price = df_lb['Close'].iloc[-1]
    prev_price = df_lb['Close'].iloc[-2] if len(df_lb) > 1 else current_price
    change = current_price - prev_price
    change_pct = (change / prev_price) * 100
    
    # VÃ©rifier si les donnÃ©es sont Ã  jour
    last_data_date = df_lb.index[-1].date()
    today = datetime.now().date()
    is_up_to_date = (today - last_data_date).days <= 1
    
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Prix", f"{current_price:.2f}", f"{change_pct:+.2f}%", key=f"price_{symbol}")
    col2.metric("Variation", f"{change:+.2f}", key=f"change_{symbol}")
    
    # Afficher la date avec un indicateur d'actualisation
    date_display = df_lb.index[-1].strftime("%d/%m/%Y")
    if not is_up_to_date:
        date_display += " âš ï¸"
    col3.metric("DerniÃ¨re MAJ", date_display, key=f"date_{symbol}")
    
    if signal_detected and bricks and len(bricks) >= 2:
        last_two = bricks[-2:]
        if last_two[0]['type'] == 'red' and last_two[1]['type'] == 'green':
            signal_type = "ðŸ”´ â†’ ðŸŸ¢ ROUGE â†’ VERT"
            signal_direction = "HAUSSE"
        else:
            signal_type = "ðŸŸ¢ â†’ ðŸ”´ VERT â†’ ROUGE"
            signal_direction = "BAISSE"
        col4.metric("Signal", signal_direction, key=f"signal_{symbol}")
        st.success(f"ðŸŽ¯ **{signal_type} dÃ©tectÃ© !** - Signal {signal_direction}")
    else:
        col4.metric("Signal", "Aucun", key=f"signal_none_{symbol}")
        st.info("ðŸ¤– Aucune alternance dÃ©tectÃ©e")
    
    if not is_up_to_date:
        st.warning(f"âš ï¸ Les donnÃ©es de {name} ne sont pas Ã  jour. DerniÃ¨re date: {df_lb.index[-1].strftime('%d/%m/%Y')}")
        st.info("ðŸ’¡ Utilisez le bouton 'Actualiser toutes les donnÃ©es' dans la sidebar pour forcer l'actualisation")
    
    # Graphiques
    tab1, tab2 = st.tabs(["ðŸ“ˆ Graphique Complet", "ðŸ§± LineBreak (3 mois)"])
    
    with tab1:
        if df_chart is not None and not df_chart.empty:
            st.plotly_chart(
                create_pro_chart(df_chart, f"{name} ({symbol}) - {chart_period}", show_bollinger, show_ema, show_macd),
                use_container_width=True,
                key=f"indiv_chart_{symbol}_{name}_{chart_period}"
            )
        else:
            st.error("DonnÃ©es non disponibles pour cette pÃ©riode")
    
    with tab2:
        if bricks:
            lb_chart = create_linebreak_chart(df_lb, bricks, f"{name} - LineBreak (3 mois)")
            if lb_chart:
                st.plotly_chart(lb_chart, use_container_width=True, key=f"indiv_lb_{symbol}_{name}")
            else:
                st.warning("DonnÃ©es LineBreak insuffisantes")
        else:
            st.info("Aucune brique LineBreak disponible")

# ---------------------------------------------------------------------
# INTERFACE PRINCIPALE
# ---------------------------------------------------------------------
def main():
    st.sidebar.title("Navigation")
    app_mode = st.sidebar.selectbox(
        "Choisir le mode:",
        ["Scanner Trading", "Analyse Individuelle", "â­ Favoris", "Analyse Technique"],
        key="main_navigation"
    )
    
    # Initialisation des favoris
    init_favoris()
    
    # Bouton d'actualisation gÃ©nÃ©ral dans la sidebar
    st.sidebar.markdown("---")
    if st.sidebar.button("ðŸ”„ Actualiser toutes les donnÃ©es", type="secondary", key="refresh_all_data"):
        st.cache_data.clear()
        # RÃ©initialiser tous les Ã©tats sauf les favoris et last_analyzed
        favoris_backup = st.session_state.get('favoris', [])
        last_analyzed_backup = st.session_state.get('last_analyzed', None)
        for key in list(st.session_state.keys()):
            if key not in ['favoris', 'last_analyzed']:
                del st.session_state[key]
        st.session_state.favoris = favoris_backup
        st.session_state.last_analyzed = last_analyzed_backup
        st.rerun()
    
    if app_mode == "Scanner Trading":
        run_scanner()
    elif app_mode == "Analyse Individuelle":
        run_individual_analysis()
    elif app_mode == "â­ Favoris":
        run_favoris()
    else:
        st.markdown("""
        ## ðŸ“Š Analyse Technique

        ### ðŸ§± LineBreak
        **RÃ¨gles de trading :**
        - ðŸ”´ â†’ ðŸŸ¢ **ROUGE puis VERT** = Tendance haussiÃ¨re
        - ðŸŸ¢ â†’ ðŸ”´ **VERT puis ROUGE** = Tendance baissiÃ¨re

        **Combinaison de signaux :**
        - âœ… **LineBreak rougeâ†’vert** + âœ… **Cours touche bande Bollinger basse** + âž¡ï¸ **Courbe tendance neutre/hausse** = ðŸ“ˆ Signal haussier renforcÃ©
        - âœ… **LineBreak vertâ†’rouge** + âœ… **Cours touche bande Bollinger haute** + âž¡ï¸ **Courbe tendance neutre/baisse** = ðŸ“‰ Signal baissier renforcÃ©

        ### ðŸ“ˆ Indicateurs Techniques IntÃ©grÃ©s

        **Bandes de Bollinger**
        - **Calcul :** Moyenne mobile 20 jours + 2 Ã©carts-types
        - **Bande supÃ©rieure =** SMA20 + (2 Ã— Ã©cart-type)
        - **Bande infÃ©rieure =** SMA20 - (2 Ã— Ã©cart-type)
        - **UtilitÃ© :** RepÃ©rer les niveaux de surachat/survente

        **EMA 20 (courbe de tendance)**
        - **Calcul :** Moyenne mobile exponentielle sur 20 jours
        - **Formule :** EMA = (Prix Ã— Î±) + (EMA_prÃ©cÃ©dent Ã— (1-Î±)) oÃ¹ Î± = 2/(20+1)
        - **InterprÃ©tation :** 
          - Courbe en hausse = tendance haussiÃ¨re
          - Courbe en baisse = tendance baissiÃ¨re  
          - Courbe plate = tendance neutre

        **MACD**
        - **Calcul :** EMA12 - EMA26 (ligne MACD)
        - **Ligne de signal :** EMA9 du MACD
        - **Histogramme :** MACD - ligne de signal
        - **InterprÃ©tation :**
          - Au-dessus de 0 = tendance haussiÃ¨re
          - En-dessous de 0 = tendance baissiÃ¨re
          - Ligne MACD croise ligne de signal = changement de momentum

        ### ðŸ”„ FonctionnalitÃ©s Interactives
        - Scan automatique du CAC40, SBF120, Dow Jones, NASDAQ100, S&P500 et plus
        - SystÃ¨me de favoris avec analyse complÃ¨te
        - Graphiques interactifs avec dates
        - Actualisation manuelle des donnÃ©es
        - Indicateurs personnalisables

        *ðŸ“ˆ DonnÃ©es Yahoo Finance â€¢ ðŸŽ¯ Algorithmes professionnels â€¢ âš ï¸ Ã€ titre Ã©ducatif uniquement*

        **âš ï¸ AVERTISSEMENT :** Ce scanner est un outil d'aide Ã  la dÃ©cision. 
        Les performances passÃ©es ne prÃ©jugent pas des performances futures. 
        Investissez uniquement l'argent que vous pouvez vous permettre de perdre.
        """)

if __name__ == "__main__":
    main()